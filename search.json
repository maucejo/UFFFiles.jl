[
  {
    "objectID": "overview/installation.html",
    "href": "overview/installation.html",
    "title": "Installation",
    "section": "",
    "text": "Note\n\n\n\nIf you are already a Julia user, you can skip this section.\nThis section explains how to install Julia and UFFFiles.jl.",
    "crumbs": [
      "Overview",
      "Installation"
    ]
  },
  {
    "objectID": "overview/installation.html#install-julia",
    "href": "overview/installation.html#install-julia",
    "title": "Installation",
    "section": "Install Julia ",
    "text": "Install Julia \nThere exists several ways of installing Julia and managing versions. The recommended way consists in installing juliaup, which is a Julia version manager.\n\nWindows\nOn Windows, juliaup can be installed directly from the Windows store or from a terminal by typing the following command:\nwinget install julia -s msstore\nMacOS and Linux\nOn MacOS and Linux, juliaup can be installed from a terminal by typing:\ncurl -fsSL https://install.julialang.org | sh\nor by using software repositories:\n# MacOS\nbrew install juliaup\n\n# Arch-based distributions\nyay -S juliaup\n\nOnce juliaup is installed, the latest version of Julia can be installed from a terminal as follows:\njuliaup add release",
    "crumbs": [
      "Overview",
      "Installation"
    ]
  },
  {
    "objectID": "overview/installation.html#install-ufffiles.jl",
    "href": "overview/installation.html#install-ufffiles.jl",
    "title": "Installation",
    "section": "Install UFFFiles.jl ",
    "text": "Install UFFFiles.jl \nThe package is registered in the Julia General Registry. So, to install the package, you can use the following command:\n(Yourenv) pkg&gt; add UFFFiles",
    "crumbs": [
      "Overview",
      "Installation"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "UFFFiles.jl",
    "section": "",
    "text": "UFFFiles.jl is a Julia package for reading and writing Universal File Format (UFF) files, commonly used in engineering applications.",
    "crumbs": [
      "Overview",
      "UFFFiles.jl"
    ]
  },
  {
    "objectID": "index.html#supported-formats",
    "href": "index.html#supported-formats",
    "title": "UFFFiles.jl",
    "section": "Supported formats",
    "text": "Supported formats\nCurrently, UFFFiles.jl supports reading and writing UFF files with the following blocks:\n\nDataset 15\nDataset 18\nDataset 55\nDataset 58\nDataset 82\nDataset 151\nDataset 164\nDataset 2411\nDataset 2412\nDataset 2414",
    "crumbs": [
      "Overview",
      "UFFFiles.jl"
    ]
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "UFFFiles.jl",
    "section": "Contributing",
    "text": "Contributing\nContributions are welcome! If you encounter any issues or have suggestions for improvements, please open an issue or submit a pull request on the GitHub repository.\nTo make contributions easier, please provide *.unv or *.uff files that can be used as test cases for the new features or bug fixes.",
    "crumbs": [
      "Overview",
      "UFFFiles.jl"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "UFFFiles.jl",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThe creation of UFFFiles.jl was driven by the need to handle UFF files in Julia for processing the experimental data that I collect during my research activities. This package take some inspiration from two wonderful packages : pyuff written in Python and uff written in Matlab. However, UFFFiles.jl is a completely new development, with its own design choices, which leverages of Julia’s strengths and provides a native solution for handling UFF files in the Julia ecosystem.\nFor testing and validate the package, I used several UFF files that are publicly available online, including some provided by pyuff and some coming from my own experimental campaigns. For this reason, I would like to thank all the people who made these files available. This also explains why bugs may still be present in the package, as I do not have access to all possible UFF file variations.",
    "crumbs": [
      "Overview",
      "UFFFiles.jl"
    ]
  },
  {
    "objectID": "index.html#reproducibility",
    "href": "index.html#reproducibility",
    "title": "UFFFiles.jl",
    "section": "Reproducibility",
    "text": "Reproducibility\n\n\n\n\n\n\nProject direct dependencies\n\n\n\n\n\nUFFFiles.jl has the following direct dependencies.\nProject UFFFiles v0.2.0\nStatus\n  [de0858da] Printf v1.11.0\n\n\n\n\n\n\n\n\n\nJulia version and machine information\n\n\n\n\n\nJulia Version 1.12.1\nCommit ba1e628ee49 (2025-10-17 13:02 UTC)\nBuild Info:\n  Official https://julialang.org release\nPlatform Info:\n  OS: macOS (arm64-apple-darwin24.0.0)\n  CPU: 16 × Apple M4 Max\n  WORD_SIZE: 64\n  LLVM: libLLVM-18.1.7 (ORCJIT, apple-m4)\n  GC: Built with stock GC\nThreads: 1 default, 1 interactive, 1 GC (on 12 virtual cores)\nEnvironment:\n  JULIA_EDITOR = code\n  JULIA_VSCODE_REPL = 1\n  JULIA_PKG_SERVER = https://juliahub.com",
    "crumbs": [
      "Overview",
      "UFFFiles.jl"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "UFFFiles.jl",
    "section": "License",
    "text": "License\nThis package is under MIT License.",
    "crumbs": [
      "Overview",
      "UFFFiles.jl"
    ]
  },
  {
    "objectID": "usage/index.html",
    "href": "usage/index.html",
    "title": "Basic Usage",
    "section": "",
    "text": "UFFFiles.jl implements reading and writing functionalities through the functions readuff and writeuff.",
    "crumbs": [
      "Usage",
      "Basic Usage"
    ]
  },
  {
    "objectID": "usage/index.html#reading-uff-files",
    "href": "usage/index.html#reading-uff-files",
    "title": "Basic Usage",
    "section": "Reading UFF Files",
    "text": "Reading UFF Files\nusing UFFFiles\n\ndata = readuff(\"path/to/your/file.uff\")\n\n\n\nreaduff(filename::String) -&gt; Vector{UFFDataset}\nReads a UFF (Universal File Format) file and parses its contents into a vector of UFFDataset objects.\nInput\n\nfilename::String: The path to the UFF file to be read.\n\n\nOutput\n\ndata::Vector{UFFDataset}: A vector containing the parsed UFF datasets.\n\n\n\n\n\n\n\n\nBecause readuff returns a vector of datasets, you can interact with a given dataset as usually done in Julia. A dataset is a Julia composite type (i.e., a struct), having its own fields, corresponding to the UFF dataset type.\nAs an example, let’s say that you have read a UFF file containing multiple datasets. You can access each dataset by indexing the returned vector and interacting with it through its fields.\n# Access to the first dataset extracted\n# Suppose that the first dataset is of type Dataset15\nd15 = data[1]\n\n# Access to the list of node coordinates\nnode_coords = d15.coords",
    "crumbs": [
      "Usage",
      "Basic Usage"
    ]
  },
  {
    "objectID": "usage/index.html#writing-uff-files",
    "href": "usage/index.html#writing-uff-files",
    "title": "Basic Usage",
    "section": "Writing UFF Files",
    "text": "Writing UFF Files\nwriteuff(\"path/to/your/file.uff\", data)\n\n\n\nwriteuff(filename::String, data::Vector{UFFDataset})\nWrites a vector of UFFDataset objects to a UFF file.\nInput\n\nfilename::String: The path to the UFF file to be written.\n\ndata::Vector{UFFDataset}: A vector containing the UFF datasets to be\n\n\nwritten.",
    "crumbs": [
      "Usage",
      "Basic Usage"
    ]
  },
  {
    "objectID": "datasets/dataset164.html",
    "href": "datasets/dataset164.html",
    "title": "Dataset 164 - Units",
    "section": "",
    "text": "Universal Dataset Number: 164\nName:   Units\nRecord 1: FORMAT(I10,20A1,I10)\n            Field 1      -- units code\n                            = 1 - SI: Meter (newton)\n                            = 2 - BG: Foot (pound f)\n                            = 3 - MG: Meter (kilogram f)\n                            = 4 - BA: Foot (poundal)\n                            = 5 - MM: mm (milli newton)\n                            = 6 - CM: cm (centi newton)\n                            = 7 - IN: Inch (pound f)\n                            = 8 - GM: mm (kilogram f)\n                            = 9 - US: USER_DEFINED\n            Field 2      -- units description (used for\n                            documentation only)\n            Field 3      -- temperature mode\n                            = 1 - absolute\n                            = 2 - relative\n\nRecord 2: FORMAT(3D25.17)\n            Unit factors for converting universal file units to SI.\n            To convert from universal file units to SI divide by\n            the appropriate factor listed below.\n            Field 1      -- length\n            Field 2      -- force\n            Field 3      -- temperature\n            Field 4      -- temperature offset",
    "crumbs": [
      "Datasets",
      "Dataset 164 - Units"
    ]
  },
  {
    "objectID": "datasets/dataset164.html#dataset-description",
    "href": "datasets/dataset164.html#dataset-description",
    "title": "Dataset 164 - Units",
    "section": "",
    "text": "Universal Dataset Number: 164\nName:   Units\nRecord 1: FORMAT(I10,20A1,I10)\n            Field 1      -- units code\n                            = 1 - SI: Meter (newton)\n                            = 2 - BG: Foot (pound f)\n                            = 3 - MG: Meter (kilogram f)\n                            = 4 - BA: Foot (poundal)\n                            = 5 - MM: mm (milli newton)\n                            = 6 - CM: cm (centi newton)\n                            = 7 - IN: Inch (pound f)\n                            = 8 - GM: mm (kilogram f)\n                            = 9 - US: USER_DEFINED\n            Field 2      -- units description (used for\n                            documentation only)\n            Field 3      -- temperature mode\n                            = 1 - absolute\n                            = 2 - relative\n\nRecord 2: FORMAT(3D25.17)\n            Unit factors for converting universal file units to SI.\n            To convert from universal file units to SI divide by\n            the appropriate factor listed below.\n            Field 1      -- length\n            Field 2      -- force\n            Field 3      -- temperature\n            Field 4      -- temperature offset",
    "crumbs": [
      "Datasets",
      "Dataset 164 - Units"
    ]
  },
  {
    "objectID": "datasets/dataset164.html#api",
    "href": "datasets/dataset164.html#api",
    "title": "Dataset 164 - Units",
    "section": "2 API",
    "text": "2 API\n\n\n\nDataset164\nA struct containing UFF Dataset 164 (Units) data.\nFields\n\ntype::Symbol: Data set type\n\nname::String: Data set name\n\nunits::Int: Units code\n\ndescription::String: Units description\n\ntemperature_mode::Int: Temperature mode\n\nconversion_length::Float64: Length conversion factor\n\nconversion_force::Float64: Force conversion factor\n\nconversion_temperature::Float64: Temperature conversion factor\n\nconversion_temperature_offset::Float64: Temperature offset conversion factor",
    "crumbs": [
      "Datasets",
      "Dataset 164 - Units"
    ]
  },
  {
    "objectID": "datasets/index.html",
    "href": "datasets/index.html",
    "title": "Preamble",
    "section": "",
    "text": "There currently exists 417 datasets in the UFF format. The complete UFF library and their descriptions can be found on the website of the University of Cincinnati. UFFFiles.jl only implements a subset of these datasets that are commonly used in structural dynamics and modale analysis.\nAs mentioned in the Home page, the UFF datasets implemented in UFFFiles.jl are:\n\nDataset 15 - Nodes\nDataset 18 - Coordinate systems\nDataset 55 - Data at nodes\nDataset 58 - Function at nodal DOF\nDataset 82 - Tracelines\nDataset 151 - Header\nDataset 164 - Units\nDataset 2411 - Nodes - Double precision\nDataset 2412 - Elements\nDataset 2414 - Analysis Data\n\nEach dataset page contains a description of the dataset as well as its API documentation.",
    "crumbs": [
      "Datasets",
      "Preamble"
    ]
  },
  {
    "objectID": "datasets/dataset82.html",
    "href": "datasets/dataset82.html",
    "title": "Dataset 82 - Tracelines",
    "section": "",
    "text": "Universal Dataset Number: 82\nName:   Tracelines\n         Record 1: FORMAT(3I10)\n                   Field 1 -    trace line number\n                   Field 2 -    number of nodes defining trace line\n                                (maximum of 250)\n                   Field 3 -    color\n\n         Record 2: FORMAT(80A1)\n                   Field 1 -    Identification line\n\n         Record 3: FORMAT(8I10)\n                   Field 1 -    nodes defining trace line\n                           =    &gt; 0 draw line to node\n                           =    0 move to node (a move to the first\n                                node is implied)\n         Notes: 1) MODAL-PLUS node numbers must not exceed 8000.\n                2) Identification line may not be blank.\n                3) Systan only uses the first 60 characters of the\n                   identification text.\n                4) MODAL-PLUS does not support trace lines longer than\n                   125 nodes.\n                5) Supertab only uses the first 40 characters of the\n                   identification line for a name.\n                6) Repeat Datasets for each Trace_Line",
    "crumbs": [
      "Datasets",
      "Dataset 82 - Tracelines"
    ]
  },
  {
    "objectID": "datasets/dataset82.html#dataset-description",
    "href": "datasets/dataset82.html#dataset-description",
    "title": "Dataset 82 - Tracelines",
    "section": "",
    "text": "Universal Dataset Number: 82\nName:   Tracelines\n         Record 1: FORMAT(3I10)\n                   Field 1 -    trace line number\n                   Field 2 -    number of nodes defining trace line\n                                (maximum of 250)\n                   Field 3 -    color\n\n         Record 2: FORMAT(80A1)\n                   Field 1 -    Identification line\n\n         Record 3: FORMAT(8I10)\n                   Field 1 -    nodes defining trace line\n                           =    &gt; 0 draw line to node\n                           =    0 move to node (a move to the first\n                                node is implied)\n         Notes: 1) MODAL-PLUS node numbers must not exceed 8000.\n                2) Identification line may not be blank.\n                3) Systan only uses the first 60 characters of the\n                   identification text.\n                4) MODAL-PLUS does not support trace lines longer than\n                   125 nodes.\n                5) Supertab only uses the first 40 characters of the\n                   identification line for a name.\n                6) Repeat Datasets for each Trace_Line",
    "crumbs": [
      "Datasets",
      "Dataset 82 - Tracelines"
    ]
  },
  {
    "objectID": "datasets/dataset82.html#api",
    "href": "datasets/dataset82.html#api",
    "title": "Dataset 82 - Tracelines",
    "section": "2 API",
    "text": "2 API\n\n\n\nDataset82\nA struct containing UFF Dataset 82 metadata.\nFields\n\ntype::Symbol: Data set type\n\nline_number::Int: Trace line number\n\nnum_nodes::Int: Number of nodes defining trace line\n\ncolor::Int: Color\n\nid_line::String: Identification line\n\nline_nodes::Vector{Int}: Nodes defining trace line",
    "crumbs": [
      "Datasets",
      "Dataset 82 - Tracelines"
    ]
  },
  {
    "objectID": "datasets/dataset2411.html",
    "href": "datasets/dataset2411.html",
    "title": "Dataset 2411 - Nodes - Double Precision",
    "section": "",
    "text": "Universal Dataset Number: 2411\nName:   Nodes - Double Precision\nRecord 1: FORMAT(4I10)\n             Field 1       -- node label\n             Field 2       -- export coordinate system number\n             Field 3       -- displacement coordinate system number\n             Field 4       -- color\n\nRecord 2: FORMAT(1P3D25.16)\n             Fields 1-3    -- node coordinates in the part coordinate\n                              system\n\nRecords 1 and 2 are repeated for each node in the model.",
    "crumbs": [
      "Datasets",
      "Dataset 2411 - Nodes - Double Precision"
    ]
  },
  {
    "objectID": "datasets/dataset2411.html#dataset-description",
    "href": "datasets/dataset2411.html#dataset-description",
    "title": "Dataset 2411 - Nodes - Double Precision",
    "section": "",
    "text": "Universal Dataset Number: 2411\nName:   Nodes - Double Precision\nRecord 1: FORMAT(4I10)\n             Field 1       -- node label\n             Field 2       -- export coordinate system number\n             Field 3       -- displacement coordinate system number\n             Field 4       -- color\n\nRecord 2: FORMAT(1P3D25.16)\n             Fields 1-3    -- node coordinates in the part coordinate\n                              system\n\nRecords 1 and 2 are repeated for each node in the model.",
    "crumbs": [
      "Datasets",
      "Dataset 2411 - Nodes - Double Precision"
    ]
  },
  {
    "objectID": "datasets/dataset2411.html#api",
    "href": "datasets/dataset2411.html#api",
    "title": "Dataset 2411 - Nodes - Double Precision",
    "section": "2 API",
    "text": "2 API\n\n\n\nDataset2411\nA struct containing UFF Dataset 2411 metadata.\nFields\n\ntype::Symbol: Data set type\n\nnodes_ID::Vector{Int}: Node IDs\n\ncoord_system::Vector{Int}: Coordinate system IDs\n\ndisp_coord_system::Vector{Int}: Displacement coordinate system IDs\n\ncolor::Vector{Int}: Color codes\n\nnode_coords::Matrix{Float64}: Node coordinates",
    "crumbs": [
      "Datasets",
      "Dataset 2411 - Nodes - Double Precision"
    ]
  },
  {
    "objectID": "datasets/dataset151.html",
    "href": "datasets/dataset151.html",
    "title": "Dataset 151 - Header",
    "section": "",
    "text": "Universal Dataset Number: 151\nName:   Header\nRecord 1: FORMAT(80A1)\n            Field 1      -- model file name\n\nRecord 2: FORMAT(80A1)\n            Field 1      -- model file description\n\nRecord 3: FORMAT(80A1)\n            Field 1      -- program which created DB\n\nRecord 4: FORMAT(10A1,10A1,3I10)\n            Field 1      -- date database created (DD-MMM-YY)\n            Field 2      -- time database created (HH:MM:SS)\n            Field 3      -- Version from database\n            Field 4      -- Version from database\n            Field 5      -- File type\n                            =0  Universal\n                            =1  Archive\n                            =2  Other\n\nRecord 5: FORMAT(10A1,10A1)\n            Field 1      -- date database last saved (DD-MMM-YY)\n            Field 2      -- time database last saved (HH:MM:SS)\n\nRecord 6: FORMAT(80A1)\n            Field 1      -- program which created universal file\n\nRecord 7: FORMAT(10A1,10A1)\n            Field 1      -- date universal file written (DD-MMM-YY)\n            Field 2      -- time universal file written (HH:MM:SS)",
    "crumbs": [
      "Datasets",
      "Dataset 151 - Header"
    ]
  },
  {
    "objectID": "datasets/dataset151.html#dataset-description",
    "href": "datasets/dataset151.html#dataset-description",
    "title": "Dataset 151 - Header",
    "section": "",
    "text": "Universal Dataset Number: 151\nName:   Header\nRecord 1: FORMAT(80A1)\n            Field 1      -- model file name\n\nRecord 2: FORMAT(80A1)\n            Field 1      -- model file description\n\nRecord 3: FORMAT(80A1)\n            Field 1      -- program which created DB\n\nRecord 4: FORMAT(10A1,10A1,3I10)\n            Field 1      -- date database created (DD-MMM-YY)\n            Field 2      -- time database created (HH:MM:SS)\n            Field 3      -- Version from database\n            Field 4      -- Version from database\n            Field 5      -- File type\n                            =0  Universal\n                            =1  Archive\n                            =2  Other\n\nRecord 5: FORMAT(10A1,10A1)\n            Field 1      -- date database last saved (DD-MMM-YY)\n            Field 2      -- time database last saved (HH:MM:SS)\n\nRecord 6: FORMAT(80A1)\n            Field 1      -- program which created universal file\n\nRecord 7: FORMAT(10A1,10A1)\n            Field 1      -- date universal file written (DD-MMM-YY)\n            Field 2      -- time universal file written (HH:MM:SS)",
    "crumbs": [
      "Datasets",
      "Dataset 151 - Header"
    ]
  },
  {
    "objectID": "datasets/dataset151.html#api",
    "href": "datasets/dataset151.html#api",
    "title": "Dataset 151 - Header",
    "section": "2 API",
    "text": "2 API\n\n\n\nDataset151\nA struct containing UFF Dataset 151 metadata.\nFields\n\ntype::Symbol: Data set type\n\nmodel_name::String: model file name\n\ndescription::String: model file description\n\napplication::String: Program which created the dataset\n\ndatetime_created::DateTime: dataset creation date and time\n\nversion::String: version from dataset\n\nfile_type::Int: file type\n\ndatetime_last_saved::DateTime: dataset last saved date and time\n\nprogram::String: program which created uff file\n\ndatetime_written::DateTime: uff file written date and time",
    "crumbs": [
      "Datasets",
      "Dataset 151 - Header"
    ]
  },
  {
    "objectID": "datasets/dataset2412.html",
    "href": "datasets/dataset2412.html",
    "title": "Dataset 2412 - Elements",
    "section": "",
    "text": "Universal Dataset Number: 2412\nName:   Elements\nRecord 1: FORMAT(6I10)\n             Field 1       -- element label\n             Field 2       -- fe descriptor id\n             Field 3       -- physical property table number\n             Field 4       -- material property table number\n             Field 5       -- color\n             Field 6       -- number of nodes on element\n\nRecord 2:  *** FOR NON-BEAM ELEMENTS ***\n             FORMAT(8I10)\n             Fields 1-n    -- node labels defining element\n\nRecord 2:  *** FOR BEAM ELEMENTS ONLY ***\n             FORMAT(3I10)\n             Field 1       -- beam orientation node number\n             Field 2       -- beam fore-end cross section number\n             Field 3       -- beam  aft-end cross section number\n\nRecord 3:  *** FOR BEAM ELEMENTS ONLY ***\n             FORMAT(8I10)\n             Fields 1-n    -- node labels defining element\n\nRecords 1 and 2 are repeated for each non-beam element in the model.\nRecords 1 - 3 are repeated for each beam element in the model.\n\nFE Descriptor Id\n\n11 Rod\n\n21 Linear beam\n\n22 Tapered beam\n\n23 Curved beam\n\n24 Parabolic beam\n\n31 Straight pipe\n\n32 Curved pipe\n\n41 Plane Stress Linear Triangle\n\n42 Plane Stress Parabolic Triangle\n\n43 Plane Stress Cubic Triangle\n\n44 Plane Stress Linear Quadrilateral\n\n45 Plane Stress Parabolic Quadrilateral\n\n46 Plane Strain Cubic Quadrilateral\n\n51 Plane Strain Linear Triangle\n\n52 Plane Strain Parabolic Triangle\n\n53 Plane Strain Cubic Triangle\n\n54 Plane Strain Linear Quadrilateral\n\n55 Plane Strain Parabolic Quadrilateral\n\n56 Plane Strain Cubic Quadrilateral\n\n61 Plate Linear Triangle\n\n62 Plate Parabolic Triangle\n\n63 Plate Cubic Triangle\n\n64 Plate Linear Quadrilateral\n\n65 Plate Parabolic Quadrilateral\n\n66 Plate Cubic Quadrilateral\n\n71 Membrane Linear Quadrilateral\n\n72 Membrane Parabolic Triangle\n\n73 Membrane Cubic Triangle\n\n74 Membrane Linear Triangle\n\n75 Membrane Parabolic Quadrilateral\n\n76 Membrane Cubic Quadrilateral\n\n81 Axisymetric Solid Linear Triangle\n\n82 Axisymetric Solid Parabolic Triangle\n\n84 Axisymetric Solid Linear Quadrilateral\n\n85 Axisymetric Solid Parabolic Quadrilateral\n\n91 Thin Shell Linear Triangle\n\n92 Thin Shell Parabolic Triangle\n\n93 Thin Shell Cubic Triangle\n\n94 Thin Shell Linear Quadrilateral\n\n95 Thin Shell Parabolic Quadrilateral\n\n96 Thin Shell Cubic Quadrilateral\n\n101 Thick Shell Linear Wedge\n\n102 Thick Shell Parabolic Wedge\n\n103 Thick Shell Cubic Wedge\n\n104 Thick Shell Linear Brick\n\n105 Thick Shell Parabolic Brick\n\n106 Thick Shell Cubic Brick\n\n111 Solid Linear Tetrahedron\n\n112 Solid Linear Wedge\n\n113 Solid Parabolic Wedge\n\n114 Solid Cubic Wedge\n\n115 Solid Linear Brick\n\n116 Solid Parabolic Brick\n\n117 Solid Cubic Brick\n\n118 Solid Parabolic Tetrahedron\n\n121 Rigid Bar\n\n122 Rigid Element\n\n136 Node To Node Translational Spring\n\n137 Node To Node Rotational Spring\n\n138 Node To Ground Translational Spring\n\n139 Node To Ground Rotational Spring\n\n141 Node To Node Damper\n\n142 Node To Ground Damper\n\n151 Node To Node Gap\n\n152 Node To Ground Gap\n\n161 Lumped Mass\n\n171 Axisymetric Linear Shell\n\n172 Axisymetric Parabolic Shell\n\n181 Constraint\n\n191 Plastic Cold Runner\n\n192 Plastic Hot Runner\n\n193 Plastic Water Line\n\n194 Plastic Fountain\n\n195 Plastic Baffle\n\n196 Plastic Rod Heater\n\n201 Linear node-to-node interface\n\n202 Linear edge-to-edge interface\n\n203 Parabolic edge-to-edge interface\n\n204 Linear face-to-face interface\n\n208 Parabolic face-to-face interface\n\n212 Linear axisymmetric interface\n\n213 Parabolic axisymmetric interface\n\n221 Linear rigid surface\n\n222 Parabolic rigin surface\n\n231 Axisymmetric linear rigid surface\n\n232 Axisymmetric parabolic rigid surface",
    "crumbs": [
      "Datasets",
      "Dataset 2412 - Elements"
    ]
  },
  {
    "objectID": "datasets/dataset2412.html#dataset-description",
    "href": "datasets/dataset2412.html#dataset-description",
    "title": "Dataset 2412 - Elements",
    "section": "",
    "text": "Universal Dataset Number: 2412\nName:   Elements\nRecord 1: FORMAT(6I10)\n             Field 1       -- element label\n             Field 2       -- fe descriptor id\n             Field 3       -- physical property table number\n             Field 4       -- material property table number\n             Field 5       -- color\n             Field 6       -- number of nodes on element\n\nRecord 2:  *** FOR NON-BEAM ELEMENTS ***\n             FORMAT(8I10)\n             Fields 1-n    -- node labels defining element\n\nRecord 2:  *** FOR BEAM ELEMENTS ONLY ***\n             FORMAT(3I10)\n             Field 1       -- beam orientation node number\n             Field 2       -- beam fore-end cross section number\n             Field 3       -- beam  aft-end cross section number\n\nRecord 3:  *** FOR BEAM ELEMENTS ONLY ***\n             FORMAT(8I10)\n             Fields 1-n    -- node labels defining element\n\nRecords 1 and 2 are repeated for each non-beam element in the model.\nRecords 1 - 3 are repeated for each beam element in the model.\n\nFE Descriptor Id\n\n11 Rod\n\n21 Linear beam\n\n22 Tapered beam\n\n23 Curved beam\n\n24 Parabolic beam\n\n31 Straight pipe\n\n32 Curved pipe\n\n41 Plane Stress Linear Triangle\n\n42 Plane Stress Parabolic Triangle\n\n43 Plane Stress Cubic Triangle\n\n44 Plane Stress Linear Quadrilateral\n\n45 Plane Stress Parabolic Quadrilateral\n\n46 Plane Strain Cubic Quadrilateral\n\n51 Plane Strain Linear Triangle\n\n52 Plane Strain Parabolic Triangle\n\n53 Plane Strain Cubic Triangle\n\n54 Plane Strain Linear Quadrilateral\n\n55 Plane Strain Parabolic Quadrilateral\n\n56 Plane Strain Cubic Quadrilateral\n\n61 Plate Linear Triangle\n\n62 Plate Parabolic Triangle\n\n63 Plate Cubic Triangle\n\n64 Plate Linear Quadrilateral\n\n65 Plate Parabolic Quadrilateral\n\n66 Plate Cubic Quadrilateral\n\n71 Membrane Linear Quadrilateral\n\n72 Membrane Parabolic Triangle\n\n73 Membrane Cubic Triangle\n\n74 Membrane Linear Triangle\n\n75 Membrane Parabolic Quadrilateral\n\n76 Membrane Cubic Quadrilateral\n\n81 Axisymetric Solid Linear Triangle\n\n82 Axisymetric Solid Parabolic Triangle\n\n84 Axisymetric Solid Linear Quadrilateral\n\n85 Axisymetric Solid Parabolic Quadrilateral\n\n91 Thin Shell Linear Triangle\n\n92 Thin Shell Parabolic Triangle\n\n93 Thin Shell Cubic Triangle\n\n94 Thin Shell Linear Quadrilateral\n\n95 Thin Shell Parabolic Quadrilateral\n\n96 Thin Shell Cubic Quadrilateral\n\n101 Thick Shell Linear Wedge\n\n102 Thick Shell Parabolic Wedge\n\n103 Thick Shell Cubic Wedge\n\n104 Thick Shell Linear Brick\n\n105 Thick Shell Parabolic Brick\n\n106 Thick Shell Cubic Brick\n\n111 Solid Linear Tetrahedron\n\n112 Solid Linear Wedge\n\n113 Solid Parabolic Wedge\n\n114 Solid Cubic Wedge\n\n115 Solid Linear Brick\n\n116 Solid Parabolic Brick\n\n117 Solid Cubic Brick\n\n118 Solid Parabolic Tetrahedron\n\n121 Rigid Bar\n\n122 Rigid Element\n\n136 Node To Node Translational Spring\n\n137 Node To Node Rotational Spring\n\n138 Node To Ground Translational Spring\n\n139 Node To Ground Rotational Spring\n\n141 Node To Node Damper\n\n142 Node To Ground Damper\n\n151 Node To Node Gap\n\n152 Node To Ground Gap\n\n161 Lumped Mass\n\n171 Axisymetric Linear Shell\n\n172 Axisymetric Parabolic Shell\n\n181 Constraint\n\n191 Plastic Cold Runner\n\n192 Plastic Hot Runner\n\n193 Plastic Water Line\n\n194 Plastic Fountain\n\n195 Plastic Baffle\n\n196 Plastic Rod Heater\n\n201 Linear node-to-node interface\n\n202 Linear edge-to-edge interface\n\n203 Parabolic edge-to-edge interface\n\n204 Linear face-to-face interface\n\n208 Parabolic face-to-face interface\n\n212 Linear axisymmetric interface\n\n213 Parabolic axisymmetric interface\n\n221 Linear rigid surface\n\n222 Parabolic rigin surface\n\n231 Axisymmetric linear rigid surface\n\n232 Axisymmetric parabolic rigid surface",
    "crumbs": [
      "Datasets",
      "Dataset 2412 - Elements"
    ]
  },
  {
    "objectID": "datasets/dataset2412.html#api",
    "href": "datasets/dataset2412.html#api",
    "title": "Dataset 2412 - Elements",
    "section": "2 API",
    "text": "2 API\n\n\n\nDataset2412\nA struct containing UFF Dataset 2412 metadata.\nFields\n\ntype::Symbol: Data set type\n\nelements_ID::Vector{Int}: Element label\n\nfe_descriptor_id::Vector{Int}: Finite element descriptor ID\n\nphys_property::Vector{Int}: Physical property table number\n\nmat_property::Vector{Int}: Material property table number\n\ncolor::Vector{Int}: Color\n\nnodes_per_elt::Vector{Int}: Number of nodes per element\n\nconnectivity::Vector{Vector{Int}}: Element connectivity (node labels)\n\nbeam_info::Vector{Vector{Int}}: Beam element information",
    "crumbs": [
      "Datasets",
      "Dataset 2412 - Elements"
    ]
  },
  {
    "objectID": "datasets/dataset18.html",
    "href": "datasets/dataset18.html",
    "title": "Dataset 18 - Coordinate systems",
    "section": "",
    "text": "Universal Dataset Number: 18\nName:   Coordinate Systems\n        Record 1: FORMAT(5I10)\n             Field 1       -- coordinate system number\n             Field 2       -- coordinate system type\n             Field 3       -- reference coordinate system number\n             Field 4       -- color\n             Field 5       -- method of definition\n                           = 1 - origin, +x axis, +xz plane\n\n        Record 2: FORMAT(20A2)\n             Field 1       -- coordinate system name\n\n        Record 3: FORMAT(1P6E13.5)\n             Total of 9 coordinate system definition parameters.\n             Fields 1-3    -- origin of new system specified in\n                              reference system\n             Fields 4-6    -- point on +x axis of the new system\n                              specified in reference system\n             Fields 7-9    -- point on +xz plane of the new system\n                              specified in reference system\nRecords 1 thru 3 are repeated for each coordinate system in the model.",
    "crumbs": [
      "Datasets",
      "Dataset 18 - Coordinate systems"
    ]
  },
  {
    "objectID": "datasets/dataset18.html#dataset-description",
    "href": "datasets/dataset18.html#dataset-description",
    "title": "Dataset 18 - Coordinate systems",
    "section": "",
    "text": "Universal Dataset Number: 18\nName:   Coordinate Systems\n        Record 1: FORMAT(5I10)\n             Field 1       -- coordinate system number\n             Field 2       -- coordinate system type\n             Field 3       -- reference coordinate system number\n             Field 4       -- color\n             Field 5       -- method of definition\n                           = 1 - origin, +x axis, +xz plane\n\n        Record 2: FORMAT(20A2)\n             Field 1       -- coordinate system name\n\n        Record 3: FORMAT(1P6E13.5)\n             Total of 9 coordinate system definition parameters.\n             Fields 1-3    -- origin of new system specified in\n                              reference system\n             Fields 4-6    -- point on +x axis of the new system\n                              specified in reference system\n             Fields 7-9    -- point on +xz plane of the new system\n                              specified in reference system\nRecords 1 thru 3 are repeated for each coordinate system in the model.",
    "crumbs": [
      "Datasets",
      "Dataset 18 - Coordinate systems"
    ]
  },
  {
    "objectID": "datasets/dataset18.html#api",
    "href": "datasets/dataset18.html#api",
    "title": "Dataset 18 - Coordinate systems",
    "section": "2 API",
    "text": "2 API\n\n\n\nDataset18\nA struct containing UFF Dataset 18 metadata.\nFields\n\ntype::Symbol: Data set type\n\ncs_num::Int: Coordinate system number\n\ncs_type::Int: Coordinate system type\n\nref_cs_num::Int: Reference coordinate system number\n\ncolor::Int: Color\n\nmethod_def::Int: Method of definition\n\ncs_name::String: Coordinate system name\n\ncs_origin::Vector{Float64}: Origin of new system specified in reference system\n\ncs_x::Vector{Float64}: Point on +x axis of the new system specified in reference system\n\ncs_xz::Vector{Float64}: Point on +xz plane of the new system specified in reference system",
    "crumbs": [
      "Datasets",
      "Dataset 18 - Coordinate systems"
    ]
  },
  {
    "objectID": "datasets/dataset2414.html",
    "href": "datasets/dataset2414.html",
    "title": "Dataset 2414 - Analysis data",
    "section": "",
    "text": "Universal Dataset Number: 2414\nName:   Analysis Data\nRecord 1: FORMAT(1I10)\n        Field 1            -- Analysis dataset label\n\nRecord 2: FORMAT(40A2)\n             Field 1       -- Analysis dataset name\n\nRecord 3: FORMAT (1I10)\n             Field 1:      -- Dataset location\n                    1:    Data at nodes\n                    2:    Data on elements\n                    3:    Data at nodes on elements\n                    5:    Data at points\n\nRecord 4: FORMAT (40A2)\n             Field 1:      -- ID line 1\n\nRecord 5: FORMAT (40A2)\n             Field 1:      -- ID line 2\n\nRecord 6: FORMAT (40A2)\n             Field 1:      -- ID line 3\n\nRecord 7: FORMAT (40A2)\n             Field 1:      -- ID line 4\n\nRecord 8: FORMAT (40A2)\n             Field 1:      -- ID line 5\n\nRecord 9: FORMAT (6I10)\n             Field 1:      -- Model type\n                               0: Unknown\n                               1: Structural\n                               2: Heat transfer\n                               3: Fluid flow\n             Field 2:      -- Analysis type\n                               0: Unknown\n                               1: Static\n                               2: Normal mode\n                               3: Complex eigenvalue first order\n                               4: Transient\n                               5: Frequency response\n                               6: Buckling\n                               7: Complex eigenvalue second order\n                               9: Static non-linear\n             Field 3:      -- Data characteristic\n                               0: Unknown\n                               1: Scalar\n                               2: 3 DOF global translation vector\n                               3: 6 DOF global translation & rotation\n                                  vector\n                               4: Symmetric global tensor\n                               6: Stress resultants\n             Field 4:      -- Result type\n                               2: Stress\n                               3: Strain\n                               4: Element force\n                               5: Temperature\n                               6: Heat flux\n                               7: Strain energy\n                               8: Displacement\n                               9: Reaction force\n                               10: Kinetic energy\n                               11: Velocity\n                               12: Acceleration\n                               13: Strain energy density\n                               14: Kinetic energy density\n                               15: Hydro-static pressure\n                               16: Heat gradient\n                               17: Code checking value\n                               18: Coefficient of pressure\n                               19: Ply stress\n                               20: Ply strain\n                               21: Failure index for ply\n                               22: Failure index for bonding\n                               23: Reaction heat flow\n                               24: Stress error density\n                               25: Stress variation\n                               27: Shell and plate elem stress resultant\n                               28: Length\n                               29: Area\n                               30: Volume\n                               31: Mass\n                               32: Constraint forces\n                               34: Plastic strain\n                               35: Creep strain\n                               36: Strain energy error\n                               37: Dynamic stress at nodes\n                               38: Heat Transfer coefficient\n                               39: Temperature gradient\n                               40: Kinetic energy dissipation rate\n                               41: Strain energy error\n                               42: Mass flow\n                               43: Mass flux\n                               44: Heat flow\n                               45: View factor\n                               46: Heat load\n                               47: Stress Component\n                               93: Unknown\n                               94: Unknown scalar\n                               95: Unknown 3DOF vector\n                               96: Unknown 6DOF vector\n                               97: Unknown symmetric tensor\n                               98: Unknown global tensor\n                               99: Unknown shell and plate resultant\n                              301: Sound Pressure\n                              302: Sound Power\n                              303: Sound Intensity\n                              304: Sound Energy\n                              305: Sound Energy Density\n                            &gt;1000: User defined result type\n             Field 5:      -- Data type\n                               1:   Integer\n                               2:   Single precision floating point\n                               4:   Double precision floating point\n                               5:   Single precision complex\n                               6:   Double precision complex\n             Field 6:      -- Number of data values for the data\n                              component (NVALDC)\n\nRecord 10: FORMAT (8I10)\n             Field 1:      -- Integer analysis type specific data (1-8)\n\nRecord 11: FORMAT (8I10)\n             Field 1:      -- Integer analysis type specific data (9,10)\n\nRecord 12: FORMAT (6E13.5)\n             Field 1:      -- Real analysis type specific data (1-6)\n\nRecord 13: FORMAT (6E13.5)\n             Field 1:      -- Real analysis type specific data (7-12)\n\nNote: See chart below for specific analysis type information.\n\nDataset class: Data at nodes\n\nRecord 14: FORMAT (I10)\n             Field 1:      -- Node number\n\nRecord 15: FORMAT (6E13.5)\n             Fields 1-N:   -- Data at this node (NDVAL real or complex\n                                                 values)\n\n             Note: Records 14 and 15 are repeated for each node.\n\nDataset class: Data at elements\n\nRecord 14: FORMAT (2I10)\n             Field 1:      -- Element number\n             Field 2:      -- Number Of data values For this element(NDVAL)\n\nRecord 15: FORMAT (6E13.5)\n             Fields 1-N:   -- Data on element(NDVAL Real Or Complex Values)\n\n             Note: Records 14 and 15 are repeated for all elements.\n\nDataset class: Data at nodes on elements\n\nRECORD 14: FORMAT (4I10)\n             Field 1:      -- Element number\n             Field 2:      -- Data expansion code (IEXP)\n                              1: Data present for all nodes\n                              2: Data present for only 1st node -All other\n                                 nodes the same.\n             Field 3:      -- Number of nodes on elements (NLOCS)\n             Field 4:      -- Number of data values per node (NVLOC)\n\nRECORD 15: FORMAT (6E13.5)\n\n             Fields 1-N:   -- Data Values At Node 1 (NVLOC Real Or\n                              Complex Values)\n\n             Note:  Records 14 And 15 Are repeated For each Element.\n\n                    For Iexp = 1 Record 15 Is repeated NLOCS Times\n                    For Iexp = 2 Record 15 appears once\n\nDataset class: Data at points\n\nRECORD 14: FORMAT (5I10)\n             Field 1:      -- Element number\n             Field 2:      -- Data expansion code (IEXP)\n                              1: Data present for all points\n                              2: Data present for only 1st point -All other\n                                 points the same.\n             Field 3:      -- Number of points on elements (NLOCS)\n             Field 4:      -- Number of data values per point (NVLOC)\n             Field 5:      -- Element order\n\nRECORD 15: FORMAT (6E13.5)\n\n             Fields 1-N:   -- Data Values At point 1 (NVLOC Real Or\n                              Complex Values)\n\n             Note:  Records 14 And 15 Are repeated For each Element.\n\n                    For Iexp = 1 Record 15 Is repeated NLOC Times\n                    For Iexp = 2 Record 15 appears once\n\n      Notes:   1.  ID lines may not be blank.  If no information\n                   is required, the word \"NONE\" must appear in\n                   columns 1-4.\n\n               2.  The data is store in\n                   \"node-layer-data charateristic\" format.\n\n                    Loc1 layer1 component1, Loc1 layer1 component2, ...\n                    Loc1 layer1 componentN, Loc1 layer2 component1, ...\n                    Loc1 Layer2 componentN, ...Loc1 layerN componentN\n                    Loc2 layer1 component1, ...Loc2 layerN componentN\n                    LocN layer1 component1, ...LocN layerN componentN\n\n               3.  For complex data there Will Be 2*NDVAL data items. The\n                   order is real part for value 1, imaginary part for\n                   value 1, real part for value 2, imaginary part for\n                   value 2, etc.\n\n               4.  The order of values for various data\n                   characteristics is:\n\n                   3 DOF Global Vector: X, Y, Z\n                   6 DOF Global Vector: X, Y, Z, Rx, Ry, Rz\n                   Symmetric Global Tensor: Sxx, Sxy, Syy,\n                                            Sxz, Syz, Szz\n\n                   Shell and Plate Element Resultant: Fx, Fy, Fxy,\n                                                      Mx, My, Mxy,\n                                                      Vx, Vy\n\n               5.  ID line 1 always appears on plots in output\n                   display.\n\n               6.  If result type is an \"UNKNOWN\" type,  id line 2\n                   is displayed as data type in output display.\n\n               7.  Data Characteristic values (Record 9, Field 3)\n                   imply the following values Of NDVALDC (Record 9,\n                   Field 6)\n                         Scalar:                   1\n                         3 DOF Global Vector:      3\n                         6 DOF Global Vector:      6\n                         Symmetric Global Tensor:  6\n                         General Global Tensor:    9\n                         Shell and Plate Resultant:8\n                   Since this value can also be derived from the Results\n                   Type (Record 9, Field 4), this is redundant data, and\n                   should be kept consistent. Some data was kept for\n                   compatibility with older files.\n\n               8.  No entry is NOT the same as a 0. entry: all 0s must\n                   be specified.\n\n               9.  A direct result of 8 is that if no records 14 and\n                   15 appear for a node or element, this entity has\n                   no data and will not be contoured, etc.\n\n               10. Dataloaders use the following id line convention:\n\n                    1.   (80A1) MODEL IDENTIFICATION\n                    2.   (80A1) RUN IDENTIFICATION\n                    3.   (80A1) RUN DATE/TIME\n                    4.   (80A1) LOAD CASE NAME\n                    For static:\n\n                    5.   (17H LOAD CASE NUMBER;, I10)\n\n                    For normal mode:\n\n                    5.   (10H MODE SAME, I10, 10H FREQUENCY, E13.5)\n\n               11. For situations with reduced # DOF'S, use 6 DOF\n                   translation and rotation with unused values = 0.\n\n               12. The integer associated data \"number retained\" will\n                   =0 unless the result set is created by sorting for\n                   extremes.  The maximum number of values to retain is 6.\n\n    Specifed values:\n      NDVAL  - Number of data values for the element.\n      NLOCS  - Number of location on the element data is stored for.\n       NVALDC - Number of values for the data component.\n\n    Derived values:\n      NLAY   - Number of location through the thickness data is stored for\n             =  NDVAL / ( NLOCS * NDVALC)\n      NVLOC  - Number of values per location.\n             =  NLAY * NVALDC\n\n    The following is always true:\n    NDVAL =  NLOCS * NLAY * NVALDC\n\n                    Dataset class: Data at nodes\n\n               1.  NLOCS = 1\n                   NLAY  = 1\n\n                   NDVAL = NVALDC\n\n               2.  Typical fortran I/O statements for the data\n                   sections are:\n\n                         READ(LUN,1000)NUM\n                         WRITE\n                    1000 FORMAT (I10)\n                         READ(LUN,1010) (VAL(I),I=1,NDVAL)\n                         WRITE\n                    1010 FORMAT (6E13.5)\n\n                         Where: VAL is real or complex data array\n                                NUM is element number\n\nDataset class: Data at elements\n\n               1.  Data on 2D type elements may have multiple values\n                   through the element thickness.  In these cases:\n                       NLOCS =1\n                           NLAY  =Number of layers of data through the\n                                  thickness.\n\n                     NDVAL = NLAY * NVALDC\n\n                   For solid elements:\n                     NLOCS = 1\n                           NLAY  = 1\n\n                     NDVAL = NVALDC\n\n                   The order of the nodes defines an outward normal which\n                   specifies the order from position 1 to NPOS.\n\n               2.  Maximum Value For NVALDC Is 9.\n                   No Maximum Value For NDVAL.\n                   No Maximum Value For NLAY.\n\n               3.  Typical fortran I/O statements for the data\n                   sections are:\n                         READ (LUN, 1000) NUM, NDVAL\n                         WRITE\n                    1000 FORMAT (2I10)\n                         READ (LUN, 1010) (VAL(I),I=1,NDVAL)\n                         WRITE\n                    1010 FORMAT (6E13.5)\n\n                         Where:  VAL is real or complex data array\n                                 NUM is element number\n\nDataset class: Data at nodes on elements\n\n               1.  Data on 2D type elements may have multiple values\n                   through the element thickness.  In these cases:\n                       NLOCS =Number of nodes for the element.\n                           NLAY  =Number of layers of data through the\n                                  thickness.\n\n                     NDVAL = NLOCS * NLAY * NVALDC\n\n                   For solid elements:\n                     NLOCS = Number of nodes for the element.\n                           NLAY  = 1\n\n                     NDVAL = NLOCS * NVALDC\n\n                   The order of the nodes defines an outward normal which\n                   specifies the order from position 1 to NPOS.\n\n               2.  Maximum Value For NVALDC Is 9.\n                   No Maximum Value For NDVAL.\n                   No Maximum Value For NLAY.\n\n               3.  Typical Fortran I/O statements for the data sections\n                   are:\n\n                         READ (LUN,1000) NUM, IEXP, NLOCS, NVLOC\n                         WRITE\n                    1000 FORMAT (4I10)\n                   C\n                   C       Process Expansion Code 1\n                   C\n                         IF (IEXP.NE.1) GO TO 20\n                         NSTRT = 1\n                         DO 10 I=1, NLOCS\n                           NSTOP = NSTRT + NVLOC - 1\n                           READ (LUN,1010) (VAL(J),J=NSTRT,STOP)\n                           WRITE\n                    1010   FORMAT (6E13.5)\n                           NSTRT = NSTRT + NVLOC\n                    10   CONTINUE\n                         GO TO 50\n                   C\n                   C       PROCESS EXPANSION CODE 2\n                   C\n                    20   READ (LUN,1010) (VAL(I),I=1,NVLOC)\n                         NOFF = 0\n                         DO 40 I=1,NLOCS\n                           NOFF = NOFF +NVLOC\n                           DO 30 J=1, NVLOC\n                             VAL (NOFF+J) = VAL(J)\n                    30     CONTINUE\n                    40   CONTINUE\n                   C\n                    50   NDVAL = NVLOC*NLOCS\n\n                         Where:    NUM is element number.\n                                   IEXP is the element expansion code\n                                   VAL is real or complex data array.\n\nDataset class: Data at points\n\n               1.  Only Tetrahedral elements will be supported.\n\n               2.  For solid elements:\n                     NLOCS = Number of points on the element data is stored\n                             for.  Determined from the element type and\n                             order.\n                           NLAY  = 1\n\n                     NDVAL = NLOCS * NVALDC\n\n               3.  Maximum Value For NVALDC Is 9.\n                   No Maximum Value For NDVAL.\n\n               4.  The element order is equal to the P-order of the element\n\n               5.  The number of points per element is calculated from\n                   the element order as follows:\n\n                     Number_of_Points = sum(i= 1 to P-Order+1)\n                                       [sum(j = 1 to i)[1 + i - j) )]]\n\n               6.  Typical Fortran I/O statements for the data sections\n                   are:\n\n                         READ (LUN,1000) NUM, IEXP, NLOCS, NVLOC, IORDER\n                         WRITE\n                    1000 FORMAT (4I10)\n                                      .\n                                      .\n                                      .\n                       (See 3. for Data at Nodes on Elements)\n\n                                   Analysis Type\n                                                                          S\n                                                                           t\n                                                                           a\n                                              C                       C    t\n                                              o           F           o    i\n                                        N     m           r           m    c\n                                        o     p           e           p\n                                        r     l           q           l    N\n                                        m     e     T                 e    o\n                                        a     x     r     R     B     x    n\n                            U           l           a     e     u\n                            n     S           E     n     s     c     E    L\n                            k     t     M     i     s     p     k     i    i\n                            n     a     o     g     i     o     l     g    n\n                            o     t     d     e     e     n     i     e    e\n                            w     i     e     n     n     s     n     n    a\n                            n     c     s     1     t     e     g     2    r\n\n       Design set ID        X     X     X     X     X     X     X     X    X\n\n       Iteration number           X     X\n\n       Solution set ID      X     X     X     X     X     X     X     X    X\nI\nN      Boundary condition   X     X     X     X     X     X     X     X    X\nT\nE      Load set                   X           X     X     X     X     X\nG\nE      Mode number                      X     X                 X     X\nR\n       Time step number                             X                      X\n\n       Frequency number                                   X\n\n       Creation option      X     X     X     X     X     X     X     X    X\n\n       Number retained      X     X     X     X     X     X     X     X    X\n\n       Time                                         X                      X\n\n       Frequency                        X                 X\n\n       Eigenvalue                                               X\n\n       Modal Mass                       X\n\n       Viscous damping                  X\n\n       Hysteretic damping               X\n\n R     Real part eigenvalue                   X                       X\n E\n A     Imaginary part eingenvalue             X                       X\n L\n       Real part of modal A                   X\n       Real part of mass                                              X\n\n       Imaginary part of modal A              X\n       Imaginary part of mass                                         X\n\n       Real part of modal B                   X\n       Real part of stiffness                                         X\n\n       Imaginary part of modal B              X\n       Imaginary part of stiffness                                    X",
    "crumbs": [
      "Datasets",
      "Dataset 2414 - Analysis data"
    ]
  },
  {
    "objectID": "datasets/dataset2414.html#dataset-description",
    "href": "datasets/dataset2414.html#dataset-description",
    "title": "Dataset 2414 - Analysis data",
    "section": "",
    "text": "Universal Dataset Number: 2414\nName:   Analysis Data\nRecord 1: FORMAT(1I10)\n        Field 1            -- Analysis dataset label\n\nRecord 2: FORMAT(40A2)\n             Field 1       -- Analysis dataset name\n\nRecord 3: FORMAT (1I10)\n             Field 1:      -- Dataset location\n                    1:    Data at nodes\n                    2:    Data on elements\n                    3:    Data at nodes on elements\n                    5:    Data at points\n\nRecord 4: FORMAT (40A2)\n             Field 1:      -- ID line 1\n\nRecord 5: FORMAT (40A2)\n             Field 1:      -- ID line 2\n\nRecord 6: FORMAT (40A2)\n             Field 1:      -- ID line 3\n\nRecord 7: FORMAT (40A2)\n             Field 1:      -- ID line 4\n\nRecord 8: FORMAT (40A2)\n             Field 1:      -- ID line 5\n\nRecord 9: FORMAT (6I10)\n             Field 1:      -- Model type\n                               0: Unknown\n                               1: Structural\n                               2: Heat transfer\n                               3: Fluid flow\n             Field 2:      -- Analysis type\n                               0: Unknown\n                               1: Static\n                               2: Normal mode\n                               3: Complex eigenvalue first order\n                               4: Transient\n                               5: Frequency response\n                               6: Buckling\n                               7: Complex eigenvalue second order\n                               9: Static non-linear\n             Field 3:      -- Data characteristic\n                               0: Unknown\n                               1: Scalar\n                               2: 3 DOF global translation vector\n                               3: 6 DOF global translation & rotation\n                                  vector\n                               4: Symmetric global tensor\n                               6: Stress resultants\n             Field 4:      -- Result type\n                               2: Stress\n                               3: Strain\n                               4: Element force\n                               5: Temperature\n                               6: Heat flux\n                               7: Strain energy\n                               8: Displacement\n                               9: Reaction force\n                               10: Kinetic energy\n                               11: Velocity\n                               12: Acceleration\n                               13: Strain energy density\n                               14: Kinetic energy density\n                               15: Hydro-static pressure\n                               16: Heat gradient\n                               17: Code checking value\n                               18: Coefficient of pressure\n                               19: Ply stress\n                               20: Ply strain\n                               21: Failure index for ply\n                               22: Failure index for bonding\n                               23: Reaction heat flow\n                               24: Stress error density\n                               25: Stress variation\n                               27: Shell and plate elem stress resultant\n                               28: Length\n                               29: Area\n                               30: Volume\n                               31: Mass\n                               32: Constraint forces\n                               34: Plastic strain\n                               35: Creep strain\n                               36: Strain energy error\n                               37: Dynamic stress at nodes\n                               38: Heat Transfer coefficient\n                               39: Temperature gradient\n                               40: Kinetic energy dissipation rate\n                               41: Strain energy error\n                               42: Mass flow\n                               43: Mass flux\n                               44: Heat flow\n                               45: View factor\n                               46: Heat load\n                               47: Stress Component\n                               93: Unknown\n                               94: Unknown scalar\n                               95: Unknown 3DOF vector\n                               96: Unknown 6DOF vector\n                               97: Unknown symmetric tensor\n                               98: Unknown global tensor\n                               99: Unknown shell and plate resultant\n                              301: Sound Pressure\n                              302: Sound Power\n                              303: Sound Intensity\n                              304: Sound Energy\n                              305: Sound Energy Density\n                            &gt;1000: User defined result type\n             Field 5:      -- Data type\n                               1:   Integer\n                               2:   Single precision floating point\n                               4:   Double precision floating point\n                               5:   Single precision complex\n                               6:   Double precision complex\n             Field 6:      -- Number of data values for the data\n                              component (NVALDC)\n\nRecord 10: FORMAT (8I10)\n             Field 1:      -- Integer analysis type specific data (1-8)\n\nRecord 11: FORMAT (8I10)\n             Field 1:      -- Integer analysis type specific data (9,10)\n\nRecord 12: FORMAT (6E13.5)\n             Field 1:      -- Real analysis type specific data (1-6)\n\nRecord 13: FORMAT (6E13.5)\n             Field 1:      -- Real analysis type specific data (7-12)\n\nNote: See chart below for specific analysis type information.\n\nDataset class: Data at nodes\n\nRecord 14: FORMAT (I10)\n             Field 1:      -- Node number\n\nRecord 15: FORMAT (6E13.5)\n             Fields 1-N:   -- Data at this node (NDVAL real or complex\n                                                 values)\n\n             Note: Records 14 and 15 are repeated for each node.\n\nDataset class: Data at elements\n\nRecord 14: FORMAT (2I10)\n             Field 1:      -- Element number\n             Field 2:      -- Number Of data values For this element(NDVAL)\n\nRecord 15: FORMAT (6E13.5)\n             Fields 1-N:   -- Data on element(NDVAL Real Or Complex Values)\n\n             Note: Records 14 and 15 are repeated for all elements.\n\nDataset class: Data at nodes on elements\n\nRECORD 14: FORMAT (4I10)\n             Field 1:      -- Element number\n             Field 2:      -- Data expansion code (IEXP)\n                              1: Data present for all nodes\n                              2: Data present for only 1st node -All other\n                                 nodes the same.\n             Field 3:      -- Number of nodes on elements (NLOCS)\n             Field 4:      -- Number of data values per node (NVLOC)\n\nRECORD 15: FORMAT (6E13.5)\n\n             Fields 1-N:   -- Data Values At Node 1 (NVLOC Real Or\n                              Complex Values)\n\n             Note:  Records 14 And 15 Are repeated For each Element.\n\n                    For Iexp = 1 Record 15 Is repeated NLOCS Times\n                    For Iexp = 2 Record 15 appears once\n\nDataset class: Data at points\n\nRECORD 14: FORMAT (5I10)\n             Field 1:      -- Element number\n             Field 2:      -- Data expansion code (IEXP)\n                              1: Data present for all points\n                              2: Data present for only 1st point -All other\n                                 points the same.\n             Field 3:      -- Number of points on elements (NLOCS)\n             Field 4:      -- Number of data values per point (NVLOC)\n             Field 5:      -- Element order\n\nRECORD 15: FORMAT (6E13.5)\n\n             Fields 1-N:   -- Data Values At point 1 (NVLOC Real Or\n                              Complex Values)\n\n             Note:  Records 14 And 15 Are repeated For each Element.\n\n                    For Iexp = 1 Record 15 Is repeated NLOC Times\n                    For Iexp = 2 Record 15 appears once\n\n      Notes:   1.  ID lines may not be blank.  If no information\n                   is required, the word \"NONE\" must appear in\n                   columns 1-4.\n\n               2.  The data is store in\n                   \"node-layer-data charateristic\" format.\n\n                    Loc1 layer1 component1, Loc1 layer1 component2, ...\n                    Loc1 layer1 componentN, Loc1 layer2 component1, ...\n                    Loc1 Layer2 componentN, ...Loc1 layerN componentN\n                    Loc2 layer1 component1, ...Loc2 layerN componentN\n                    LocN layer1 component1, ...LocN layerN componentN\n\n               3.  For complex data there Will Be 2*NDVAL data items. The\n                   order is real part for value 1, imaginary part for\n                   value 1, real part for value 2, imaginary part for\n                   value 2, etc.\n\n               4.  The order of values for various data\n                   characteristics is:\n\n                   3 DOF Global Vector: X, Y, Z\n                   6 DOF Global Vector: X, Y, Z, Rx, Ry, Rz\n                   Symmetric Global Tensor: Sxx, Sxy, Syy,\n                                            Sxz, Syz, Szz\n\n                   Shell and Plate Element Resultant: Fx, Fy, Fxy,\n                                                      Mx, My, Mxy,\n                                                      Vx, Vy\n\n               5.  ID line 1 always appears on plots in output\n                   display.\n\n               6.  If result type is an \"UNKNOWN\" type,  id line 2\n                   is displayed as data type in output display.\n\n               7.  Data Characteristic values (Record 9, Field 3)\n                   imply the following values Of NDVALDC (Record 9,\n                   Field 6)\n                         Scalar:                   1\n                         3 DOF Global Vector:      3\n                         6 DOF Global Vector:      6\n                         Symmetric Global Tensor:  6\n                         General Global Tensor:    9\n                         Shell and Plate Resultant:8\n                   Since this value can also be derived from the Results\n                   Type (Record 9, Field 4), this is redundant data, and\n                   should be kept consistent. Some data was kept for\n                   compatibility with older files.\n\n               8.  No entry is NOT the same as a 0. entry: all 0s must\n                   be specified.\n\n               9.  A direct result of 8 is that if no records 14 and\n                   15 appear for a node or element, this entity has\n                   no data and will not be contoured, etc.\n\n               10. Dataloaders use the following id line convention:\n\n                    1.   (80A1) MODEL IDENTIFICATION\n                    2.   (80A1) RUN IDENTIFICATION\n                    3.   (80A1) RUN DATE/TIME\n                    4.   (80A1) LOAD CASE NAME\n                    For static:\n\n                    5.   (17H LOAD CASE NUMBER;, I10)\n\n                    For normal mode:\n\n                    5.   (10H MODE SAME, I10, 10H FREQUENCY, E13.5)\n\n               11. For situations with reduced # DOF'S, use 6 DOF\n                   translation and rotation with unused values = 0.\n\n               12. The integer associated data \"number retained\" will\n                   =0 unless the result set is created by sorting for\n                   extremes.  The maximum number of values to retain is 6.\n\n    Specifed values:\n      NDVAL  - Number of data values for the element.\n      NLOCS  - Number of location on the element data is stored for.\n       NVALDC - Number of values for the data component.\n\n    Derived values:\n      NLAY   - Number of location through the thickness data is stored for\n             =  NDVAL / ( NLOCS * NDVALC)\n      NVLOC  - Number of values per location.\n             =  NLAY * NVALDC\n\n    The following is always true:\n    NDVAL =  NLOCS * NLAY * NVALDC\n\n                    Dataset class: Data at nodes\n\n               1.  NLOCS = 1\n                   NLAY  = 1\n\n                   NDVAL = NVALDC\n\n               2.  Typical fortran I/O statements for the data\n                   sections are:\n\n                         READ(LUN,1000)NUM\n                         WRITE\n                    1000 FORMAT (I10)\n                         READ(LUN,1010) (VAL(I),I=1,NDVAL)\n                         WRITE\n                    1010 FORMAT (6E13.5)\n\n                         Where: VAL is real or complex data array\n                                NUM is element number\n\nDataset class: Data at elements\n\n               1.  Data on 2D type elements may have multiple values\n                   through the element thickness.  In these cases:\n                       NLOCS =1\n                           NLAY  =Number of layers of data through the\n                                  thickness.\n\n                     NDVAL = NLAY * NVALDC\n\n                   For solid elements:\n                     NLOCS = 1\n                           NLAY  = 1\n\n                     NDVAL = NVALDC\n\n                   The order of the nodes defines an outward normal which\n                   specifies the order from position 1 to NPOS.\n\n               2.  Maximum Value For NVALDC Is 9.\n                   No Maximum Value For NDVAL.\n                   No Maximum Value For NLAY.\n\n               3.  Typical fortran I/O statements for the data\n                   sections are:\n                         READ (LUN, 1000) NUM, NDVAL\n                         WRITE\n                    1000 FORMAT (2I10)\n                         READ (LUN, 1010) (VAL(I),I=1,NDVAL)\n                         WRITE\n                    1010 FORMAT (6E13.5)\n\n                         Where:  VAL is real or complex data array\n                                 NUM is element number\n\nDataset class: Data at nodes on elements\n\n               1.  Data on 2D type elements may have multiple values\n                   through the element thickness.  In these cases:\n                       NLOCS =Number of nodes for the element.\n                           NLAY  =Number of layers of data through the\n                                  thickness.\n\n                     NDVAL = NLOCS * NLAY * NVALDC\n\n                   For solid elements:\n                     NLOCS = Number of nodes for the element.\n                           NLAY  = 1\n\n                     NDVAL = NLOCS * NVALDC\n\n                   The order of the nodes defines an outward normal which\n                   specifies the order from position 1 to NPOS.\n\n               2.  Maximum Value For NVALDC Is 9.\n                   No Maximum Value For NDVAL.\n                   No Maximum Value For NLAY.\n\n               3.  Typical Fortran I/O statements for the data sections\n                   are:\n\n                         READ (LUN,1000) NUM, IEXP, NLOCS, NVLOC\n                         WRITE\n                    1000 FORMAT (4I10)\n                   C\n                   C       Process Expansion Code 1\n                   C\n                         IF (IEXP.NE.1) GO TO 20\n                         NSTRT = 1\n                         DO 10 I=1, NLOCS\n                           NSTOP = NSTRT + NVLOC - 1\n                           READ (LUN,1010) (VAL(J),J=NSTRT,STOP)\n                           WRITE\n                    1010   FORMAT (6E13.5)\n                           NSTRT = NSTRT + NVLOC\n                    10   CONTINUE\n                         GO TO 50\n                   C\n                   C       PROCESS EXPANSION CODE 2\n                   C\n                    20   READ (LUN,1010) (VAL(I),I=1,NVLOC)\n                         NOFF = 0\n                         DO 40 I=1,NLOCS\n                           NOFF = NOFF +NVLOC\n                           DO 30 J=1, NVLOC\n                             VAL (NOFF+J) = VAL(J)\n                    30     CONTINUE\n                    40   CONTINUE\n                   C\n                    50   NDVAL = NVLOC*NLOCS\n\n                         Where:    NUM is element number.\n                                   IEXP is the element expansion code\n                                   VAL is real or complex data array.\n\nDataset class: Data at points\n\n               1.  Only Tetrahedral elements will be supported.\n\n               2.  For solid elements:\n                     NLOCS = Number of points on the element data is stored\n                             for.  Determined from the element type and\n                             order.\n                           NLAY  = 1\n\n                     NDVAL = NLOCS * NVALDC\n\n               3.  Maximum Value For NVALDC Is 9.\n                   No Maximum Value For NDVAL.\n\n               4.  The element order is equal to the P-order of the element\n\n               5.  The number of points per element is calculated from\n                   the element order as follows:\n\n                     Number_of_Points = sum(i= 1 to P-Order+1)\n                                       [sum(j = 1 to i)[1 + i - j) )]]\n\n               6.  Typical Fortran I/O statements for the data sections\n                   are:\n\n                         READ (LUN,1000) NUM, IEXP, NLOCS, NVLOC, IORDER\n                         WRITE\n                    1000 FORMAT (4I10)\n                                      .\n                                      .\n                                      .\n                       (See 3. for Data at Nodes on Elements)\n\n                                   Analysis Type\n                                                                          S\n                                                                           t\n                                                                           a\n                                              C                       C    t\n                                              o           F           o    i\n                                        N     m           r           m    c\n                                        o     p           e           p\n                                        r     l           q           l    N\n                                        m     e     T                 e    o\n                                        a     x     r     R     B     x    n\n                            U           l           a     e     u\n                            n     S           E     n     s     c     E    L\n                            k     t     M     i     s     p     k     i    i\n                            n     a     o     g     i     o     l     g    n\n                            o     t     d     e     e     n     i     e    e\n                            w     i     e     n     n     s     n     n    a\n                            n     c     s     1     t     e     g     2    r\n\n       Design set ID        X     X     X     X     X     X     X     X    X\n\n       Iteration number           X     X\n\n       Solution set ID      X     X     X     X     X     X     X     X    X\nI\nN      Boundary condition   X     X     X     X     X     X     X     X    X\nT\nE      Load set                   X           X     X     X     X     X\nG\nE      Mode number                      X     X                 X     X\nR\n       Time step number                             X                      X\n\n       Frequency number                                   X\n\n       Creation option      X     X     X     X     X     X     X     X    X\n\n       Number retained      X     X     X     X     X     X     X     X    X\n\n       Time                                         X                      X\n\n       Frequency                        X                 X\n\n       Eigenvalue                                               X\n\n       Modal Mass                       X\n\n       Viscous damping                  X\n\n       Hysteretic damping               X\n\n R     Real part eigenvalue                   X                       X\n E\n A     Imaginary part eingenvalue             X                       X\n L\n       Real part of modal A                   X\n       Real part of mass                                              X\n\n       Imaginary part of modal A              X\n       Imaginary part of mass                                         X\n\n       Real part of modal B                   X\n       Real part of stiffness                                         X\n\n       Imaginary part of modal B              X\n       Imaginary part of stiffness                                    X",
    "crumbs": [
      "Datasets",
      "Dataset 2414 - Analysis data"
    ]
  },
  {
    "objectID": "datasets/dataset2414.html#api",
    "href": "datasets/dataset2414.html#api",
    "title": "Dataset 2414 - Analysis data",
    "section": "2 API",
    "text": "2 API\n\n\n\nDataset2414\nA struct containing UFF Dataset 2414 metadata.\nFields\n\ntype::Symbol: Data set type\n\nanalysis_dlabel::Int: Analysyis data label\n\nanalysis_dname::String: Analysis data name\n\ndataset_location::Int: Dataset location\n\nid_line1::String: ID line 1\n\nid_line2::String: ID line 2\n\nid_line3::String: ID line 3\n\nid_line4::String: ID line 4\n\nid_line5::String: ID line 5\n\nmodel_type::Int: Model type\n\nanalysis_type::Int: Analysis type\n\ndata_characteristic::Int: Data characteristic\n\nresult_type::Int: Result type\n\ndtype::Int: Data type\n\nnum_data_values::Int: Number of data values\n\nint_analysis_type::NamedTuple: Integer analysis type information\n\nreal_analysis_type::NamedTuple: Real analysis type information\n\ndata_info::NamedTuple: Data information\n\ndata_value::AbstractArray: Data values",
    "crumbs": [
      "Datasets",
      "Dataset 2414 - Analysis data"
    ]
  },
  {
    "objectID": "datasets/dataset55.html",
    "href": "datasets/dataset55.html",
    "title": "Dataset 55 - Data at nodes",
    "section": "",
    "text": "Universal Dataset Number: 55\nName:   Data at Nodes\n      RECORD 1:      Format (40A2)\n           FIELD 1:          ID Line 1\n\n      RECORD 2:      Format (40A2)\n           FIELD 1:          ID Line 2\n\n      RECORD 3:      Format (40A2)\n\n           FIELD 1:          ID Line 3\n\n      RECORD 4:      Format (40A2)\n           FIELD 1:          ID Line 4\n\n      RECORD 5:      Format (40A2)\n           FIELD 1:          ID Line 5\n\n      RECORD 6:      Format (6I10)\n\n      Data Definition Parameters\n\n           FIELD 1: Model Type\n                       0:   Unknown\n                       1:   Structural\n                       2:   Heat Transfer\n                       3:   Fluid Flow\n\n           FIELD 2:  Analysis Type\n                       0:   Unknown\n                       1:   Static\n                       2:   Normal Mode\n                       3:   Complex eigenvalue first order\n                       4:   Transient\n                       5:   Frequency Response\n                       6:   Buckling\n                       7:   Complex eigenvalue second order\n\n           FIELD 3:  Data Characteristic\n                       0:   Unknown\n                       1:   Scalar\n                       2:   3 DOF Global Translation\n                            Vector\n                       3:   6 DOF Global Translation\n                            & Rotation Vector\n                       4:   Symmetric Global Tensor\n                       5:   General Global Tensor\n\n           FIELD 4: Specific Data Type\n                       0:   Unknown\n                       1:   General\n                       2:   Stress\n                       3:   Strain\n                       4:   Element Force\n                       5:   Temperature\n                       6:   Heat Flux\n                       7:   Strain Energy\n                       8:   Displacement\n                       9:   Reaction Force\n                       10:   Kinetic Energy\n                       11:   Velocity\n                       12:   Acceleration\n                       13:   Strain Energy Density\n                       14:   Kinetic Energy Density\n                       15:   Hydro-Static Pressure\n                       16:   Heat Gradient\n                       17:   Code Checking Value\n                       18:   Coefficient Of Pressure\n\n           FIELD 5:  Data Type\n                       2:   Real\n                       5:   Complex\n\n           FIELD 6:  Number Of Data Values Per Node (NDV)\n\n      Records 7 And 8 Are Analysis Type Specific\n\n      General Form\n\n      RECORD 7:      Format (8I10)\n           FIELD 1:          Number Of Integer Data Values\n                       1 &lt; Or = Nint &lt; Or = 10\n           FIELD 2:          Number Of Real Data Values\n                       1 &lt; Or = Nrval &lt; Or = 12\n           FIELDS 3-N:       Type Specific Integer Parameters\n\n      RECORD 8:      Format (6E13.5)\n           FIELDS 1-N:       Type Specific Real Parameters\n\n      For Analysis Type = 0, Unknown\n\n      RECORD 7:\n           FIELD 1:   1\n           FIELD 2:   1\n           FIELD 3:   ID Number\n\n      RECORD 8:\n\n           FIELD 1:   0.0\n\n      For Analysis Type = 1, Static\n\n      RECORD 7:\n           FIELD 1:    1\n           FIELD 2:    1\n           FIELD 3:    Load Case Number\n\n      RECORD 8:\n           FIELD 11:    0.0\n\n      For Analysis Type = 2, Normal Mode\n\n      RECORD 7:\n           FIELD 1:    2\n           FIELD 2:    4\n           FIELD 3:    Load Case Number\n           FIELD 4:    Mode Number\n\n      RECORD 8:\n           FIELD 1:    Frequency (Hertz)\n           FIELD 2:    Modal Mass\n           FIELD 3:    Modal Viscous Damping Ratio\n           FIELD 4:    Modal Hysteretic Damping Ratio\n\n      For Analysis Type = 3, Complex Eigenvalue\n\n      RECORD 7:\n           FIELD 1:    2\n           FIELD 2:    6\n           FIELD 3:    Load Case Number\n           FIELD 4:    Mode Number\n\n      RECORD 8:\n           FIELD 1:    Real Part Eigenvalue\n           FIELD 2:    Imaginary Part Eigenvalue\n           FIELD 3:    Real Part Of Modal A\n           FIELD 4:    Imaginary Part Of Modal A\n           FIELD 5:    Real Part Of Modal B\n           FIELD 6:    Imaginary Part Of Modal B\n\n      For Analysis Type = 4, Transient\n\n      RECORD 7:\n           FIELD 1:    2\n           FIELD 2:    1\n           FIELD 3:    Load Case Number\n           FIELD 4:    Time Step Number\n\n      RECORD 8:\n           FIELD 1: Time (Seconds)\n\n      For Analysis Type = 5, Frequency Response\n\n      RECORD 7:\n           FIELD 1:    2\n           FIELD 2:    1\n           FIELD 3:    Load Case Number\n           FIELD 4:    Frequency Step Number\n\n      RECORD 8:\n           FIELD 1:    Frequency (Hertz)\n\n      For Analysis Type = 6, Buckling\n\n      RECORD 7:\n           FIELD 1:    1\n           FIELD 2:    1\n           FIELD 3:    Load Case Number\n\n      RECORD 8:\n           FIELD 1: Eigenvalue\n\n      RECORD 9:      Format (I10)\n           FIELD 1:          Node Number\n\n      RECORD 10:     Format (6E13.5)\n           FIELDS 1-N:       Data At This Node (NDV Real Or\n                     Complex Values)\n\n      Records 9 And 10 Are Repeated For Each Node.\n\n      Notes:\n      1        Id Lines May Not Be Blank.  If No Information Is\n                  Required, The Word \"None\" Must Appear  Columns 1-4.\n\n      2        For Complex Data There Will Be 2*Ndv Data Items At Each\n                  Node. The Order Is Real Part For Value 1,  Imaginary\n                  Part For Value 1, Etc.\n      3        The Order Of Values For Various Data  Characteristics\n                  Is:\n                      3 DOF Global Vector:\n                              X, Y, Z\n\n                      6 DOF Global Vector:\n                              X, Y, Z,\n                              Rx, Ry, Rz\n\n                      Symmetric Global Tensor:\n                              Sxx, Sxy, Syy,\n                              Sxz, Syz, Szz\n\n                      General Global Tensor:\n                              Sxx, Syx, Szx,\n                              Sxy, Syy, Szy,\n                              Sxz, Syz, Szz\n\n                      Shell And Plate Element Load:\n                              Fx, Fy, Fxy,\n                              Mx, My, Mxy,\n                              Vx, Vy\n\n      4        Id Line 1 Always Appears On Plots In Output Display.\n      5        If Specific Data Type Is \"Unknown,\" ID Line 2 Is\n                  Displayed As Data Type In Output Display.\n      6        Typical Fortran I/O Statements For The Data Sections\n                  Are:\n\n                               Read(Lun,1000)Num\n                               Write\n                      1000 Format (I10)\n                               Read(Lun,1010) (VAL(I),I=1,NDV)\n                               Write\n                      1010 format (6e13.5)\n\n                      Where:     Num Is Node Number\n                                 Val Is Real Or Complex Data  Array\n                                 Ndv Is Number Of Data Values  Per Node\n\n      7         Data Characteristic Values Imply The Following Values\n                  Of Ndv:\n                    Scalar: 1\n                    3 DOF Global Vector: 3\n                    6 DOF Global Vector: 6\n                    Symmetric Global Tensor: 6\n                    General Global Tensor: 9\n\n      8        Data Associated With I-DEAS Test Has The Following\n                  Special Forms of Specific Data Type and ID Line 5.\n\n               For Record 6 Field 4-Specific Data Type, values 0\n               through 12 are as defined above.  13 and 15 through 19 are:\n\n                           13: excitation force\n                           15: pressure\n                           16: mass\n                           17: time\n                           18: frequency\n                           19: rpm\n\n               The form of ID Line 5 is:\n\n               Format (4I10)\n               FIELD 1:  Reference Coordinate Label\n\n               FIELD 2:  Reference Coordinate Direction\n                            1: X Direction\n                           -1: -X Direction\n                            2: Y Direction\n                           -2: -Y Direction\n                            3: Z Direction\n                           -3: -Z Direction\n\n               FIELD 3:  Numerator Signal Code\n                            see Specific Data Type above\n\n               FIELD 4:  Denominator Signal Code\n                            see Specific Data Type above\n\n\n               Also note that the modal mass in record 8 is calculated\n               from the parameter table by I-DEAS Test.\n\n      9        Any Record With All 0.0's Data Entries Need Not (But\n                  May) Appear.\n\n      10       A Direct Result Of 9 Is That If No Records 9 And 10\n                  Appear, All Data For The Data Set Is 0.0.\n\n      11       When New Analysis Types Are Added, Record 7 Fields 1\n                  And 2 Are Always &gt; Or = 1 With Dummy Integer And\n                  Real Zero Data If Data Is Not Required. If Complex\n                  Data Is Needed, It Is Treated As Two Real Numbers,\n                  Real Part Followed By Imaginary Point.\n\n      12       Dataloaders Use The Following ID Line Convention:\n                          1.   (80A1) Model\n                              Identification\n                          2.   (80A1) Run\n                              Identification\n                          3.   (80A1) Run\n                              Date/Time\n                          4.   (80A1) Load Case\n                              Name\n\n                      For Static:\n                          5.   (17h Load Case\n                              Number;, I10) For\n                              Normal Mode:\n                          5.   (10h Mode Same,\n                              I10, 10H Frequency,\n                              E13.5)\n      13       No Maximum Value For Ndv .\n\n      14       Typical Fortran I/O Statements For Processing Records 7\n                  And 8.\n\n                        Read (LUN,1000)NINT,NRVAL,(IPAR(I),I=1,NINT\n                   1000 Format (8I10)\n                        Read (Lun,1010) (RPAV(I),I=1,NRVAL)\n                   1010 Format (6E13.5)\n\n      15       For Situations With Reduced # Dof's, Use 3 DOF\n                  Translations Or 6 DOF Translation And Rotation With\n                  Unused Values = 0.",
    "crumbs": [
      "Datasets",
      "Dataset 55 - Data at nodes"
    ]
  },
  {
    "objectID": "datasets/dataset55.html#dataset-description",
    "href": "datasets/dataset55.html#dataset-description",
    "title": "Dataset 55 - Data at nodes",
    "section": "",
    "text": "Universal Dataset Number: 55\nName:   Data at Nodes\n      RECORD 1:      Format (40A2)\n           FIELD 1:          ID Line 1\n\n      RECORD 2:      Format (40A2)\n           FIELD 1:          ID Line 2\n\n      RECORD 3:      Format (40A2)\n\n           FIELD 1:          ID Line 3\n\n      RECORD 4:      Format (40A2)\n           FIELD 1:          ID Line 4\n\n      RECORD 5:      Format (40A2)\n           FIELD 1:          ID Line 5\n\n      RECORD 6:      Format (6I10)\n\n      Data Definition Parameters\n\n           FIELD 1: Model Type\n                       0:   Unknown\n                       1:   Structural\n                       2:   Heat Transfer\n                       3:   Fluid Flow\n\n           FIELD 2:  Analysis Type\n                       0:   Unknown\n                       1:   Static\n                       2:   Normal Mode\n                       3:   Complex eigenvalue first order\n                       4:   Transient\n                       5:   Frequency Response\n                       6:   Buckling\n                       7:   Complex eigenvalue second order\n\n           FIELD 3:  Data Characteristic\n                       0:   Unknown\n                       1:   Scalar\n                       2:   3 DOF Global Translation\n                            Vector\n                       3:   6 DOF Global Translation\n                            & Rotation Vector\n                       4:   Symmetric Global Tensor\n                       5:   General Global Tensor\n\n           FIELD 4: Specific Data Type\n                       0:   Unknown\n                       1:   General\n                       2:   Stress\n                       3:   Strain\n                       4:   Element Force\n                       5:   Temperature\n                       6:   Heat Flux\n                       7:   Strain Energy\n                       8:   Displacement\n                       9:   Reaction Force\n                       10:   Kinetic Energy\n                       11:   Velocity\n                       12:   Acceleration\n                       13:   Strain Energy Density\n                       14:   Kinetic Energy Density\n                       15:   Hydro-Static Pressure\n                       16:   Heat Gradient\n                       17:   Code Checking Value\n                       18:   Coefficient Of Pressure\n\n           FIELD 5:  Data Type\n                       2:   Real\n                       5:   Complex\n\n           FIELD 6:  Number Of Data Values Per Node (NDV)\n\n      Records 7 And 8 Are Analysis Type Specific\n\n      General Form\n\n      RECORD 7:      Format (8I10)\n           FIELD 1:          Number Of Integer Data Values\n                       1 &lt; Or = Nint &lt; Or = 10\n           FIELD 2:          Number Of Real Data Values\n                       1 &lt; Or = Nrval &lt; Or = 12\n           FIELDS 3-N:       Type Specific Integer Parameters\n\n      RECORD 8:      Format (6E13.5)\n           FIELDS 1-N:       Type Specific Real Parameters\n\n      For Analysis Type = 0, Unknown\n\n      RECORD 7:\n           FIELD 1:   1\n           FIELD 2:   1\n           FIELD 3:   ID Number\n\n      RECORD 8:\n\n           FIELD 1:   0.0\n\n      For Analysis Type = 1, Static\n\n      RECORD 7:\n           FIELD 1:    1\n           FIELD 2:    1\n           FIELD 3:    Load Case Number\n\n      RECORD 8:\n           FIELD 11:    0.0\n\n      For Analysis Type = 2, Normal Mode\n\n      RECORD 7:\n           FIELD 1:    2\n           FIELD 2:    4\n           FIELD 3:    Load Case Number\n           FIELD 4:    Mode Number\n\n      RECORD 8:\n           FIELD 1:    Frequency (Hertz)\n           FIELD 2:    Modal Mass\n           FIELD 3:    Modal Viscous Damping Ratio\n           FIELD 4:    Modal Hysteretic Damping Ratio\n\n      For Analysis Type = 3, Complex Eigenvalue\n\n      RECORD 7:\n           FIELD 1:    2\n           FIELD 2:    6\n           FIELD 3:    Load Case Number\n           FIELD 4:    Mode Number\n\n      RECORD 8:\n           FIELD 1:    Real Part Eigenvalue\n           FIELD 2:    Imaginary Part Eigenvalue\n           FIELD 3:    Real Part Of Modal A\n           FIELD 4:    Imaginary Part Of Modal A\n           FIELD 5:    Real Part Of Modal B\n           FIELD 6:    Imaginary Part Of Modal B\n\n      For Analysis Type = 4, Transient\n\n      RECORD 7:\n           FIELD 1:    2\n           FIELD 2:    1\n           FIELD 3:    Load Case Number\n           FIELD 4:    Time Step Number\n\n      RECORD 8:\n           FIELD 1: Time (Seconds)\n\n      For Analysis Type = 5, Frequency Response\n\n      RECORD 7:\n           FIELD 1:    2\n           FIELD 2:    1\n           FIELD 3:    Load Case Number\n           FIELD 4:    Frequency Step Number\n\n      RECORD 8:\n           FIELD 1:    Frequency (Hertz)\n\n      For Analysis Type = 6, Buckling\n\n      RECORD 7:\n           FIELD 1:    1\n           FIELD 2:    1\n           FIELD 3:    Load Case Number\n\n      RECORD 8:\n           FIELD 1: Eigenvalue\n\n      RECORD 9:      Format (I10)\n           FIELD 1:          Node Number\n\n      RECORD 10:     Format (6E13.5)\n           FIELDS 1-N:       Data At This Node (NDV Real Or\n                     Complex Values)\n\n      Records 9 And 10 Are Repeated For Each Node.\n\n      Notes:\n      1        Id Lines May Not Be Blank.  If No Information Is\n                  Required, The Word \"None\" Must Appear  Columns 1-4.\n\n      2        For Complex Data There Will Be 2*Ndv Data Items At Each\n                  Node. The Order Is Real Part For Value 1,  Imaginary\n                  Part For Value 1, Etc.\n      3        The Order Of Values For Various Data  Characteristics\n                  Is:\n                      3 DOF Global Vector:\n                              X, Y, Z\n\n                      6 DOF Global Vector:\n                              X, Y, Z,\n                              Rx, Ry, Rz\n\n                      Symmetric Global Tensor:\n                              Sxx, Sxy, Syy,\n                              Sxz, Syz, Szz\n\n                      General Global Tensor:\n                              Sxx, Syx, Szx,\n                              Sxy, Syy, Szy,\n                              Sxz, Syz, Szz\n\n                      Shell And Plate Element Load:\n                              Fx, Fy, Fxy,\n                              Mx, My, Mxy,\n                              Vx, Vy\n\n      4        Id Line 1 Always Appears On Plots In Output Display.\n      5        If Specific Data Type Is \"Unknown,\" ID Line 2 Is\n                  Displayed As Data Type In Output Display.\n      6        Typical Fortran I/O Statements For The Data Sections\n                  Are:\n\n                               Read(Lun,1000)Num\n                               Write\n                      1000 Format (I10)\n                               Read(Lun,1010) (VAL(I),I=1,NDV)\n                               Write\n                      1010 format (6e13.5)\n\n                      Where:     Num Is Node Number\n                                 Val Is Real Or Complex Data  Array\n                                 Ndv Is Number Of Data Values  Per Node\n\n      7         Data Characteristic Values Imply The Following Values\n                  Of Ndv:\n                    Scalar: 1\n                    3 DOF Global Vector: 3\n                    6 DOF Global Vector: 6\n                    Symmetric Global Tensor: 6\n                    General Global Tensor: 9\n\n      8        Data Associated With I-DEAS Test Has The Following\n                  Special Forms of Specific Data Type and ID Line 5.\n\n               For Record 6 Field 4-Specific Data Type, values 0\n               through 12 are as defined above.  13 and 15 through 19 are:\n\n                           13: excitation force\n                           15: pressure\n                           16: mass\n                           17: time\n                           18: frequency\n                           19: rpm\n\n               The form of ID Line 5 is:\n\n               Format (4I10)\n               FIELD 1:  Reference Coordinate Label\n\n               FIELD 2:  Reference Coordinate Direction\n                            1: X Direction\n                           -1: -X Direction\n                            2: Y Direction\n                           -2: -Y Direction\n                            3: Z Direction\n                           -3: -Z Direction\n\n               FIELD 3:  Numerator Signal Code\n                            see Specific Data Type above\n\n               FIELD 4:  Denominator Signal Code\n                            see Specific Data Type above\n\n\n               Also note that the modal mass in record 8 is calculated\n               from the parameter table by I-DEAS Test.\n\n      9        Any Record With All 0.0's Data Entries Need Not (But\n                  May) Appear.\n\n      10       A Direct Result Of 9 Is That If No Records 9 And 10\n                  Appear, All Data For The Data Set Is 0.0.\n\n      11       When New Analysis Types Are Added, Record 7 Fields 1\n                  And 2 Are Always &gt; Or = 1 With Dummy Integer And\n                  Real Zero Data If Data Is Not Required. If Complex\n                  Data Is Needed, It Is Treated As Two Real Numbers,\n                  Real Part Followed By Imaginary Point.\n\n      12       Dataloaders Use The Following ID Line Convention:\n                          1.   (80A1) Model\n                              Identification\n                          2.   (80A1) Run\n                              Identification\n                          3.   (80A1) Run\n                              Date/Time\n                          4.   (80A1) Load Case\n                              Name\n\n                      For Static:\n                          5.   (17h Load Case\n                              Number;, I10) For\n                              Normal Mode:\n                          5.   (10h Mode Same,\n                              I10, 10H Frequency,\n                              E13.5)\n      13       No Maximum Value For Ndv .\n\n      14       Typical Fortran I/O Statements For Processing Records 7\n                  And 8.\n\n                        Read (LUN,1000)NINT,NRVAL,(IPAR(I),I=1,NINT\n                   1000 Format (8I10)\n                        Read (Lun,1010) (RPAV(I),I=1,NRVAL)\n                   1010 Format (6E13.5)\n\n      15       For Situations With Reduced # Dof's, Use 3 DOF\n                  Translations Or 6 DOF Translation And Rotation With\n                  Unused Values = 0.",
    "crumbs": [
      "Datasets",
      "Dataset 55 - Data at nodes"
    ]
  },
  {
    "objectID": "datasets/dataset55.html#api",
    "href": "datasets/dataset55.html#api",
    "title": "Dataset 55 - Data at nodes",
    "section": "2 API",
    "text": "2 API\n\n\n\nDataset55\nA struct containing UFF Dataset 55 metadata.\nFields\n\ntype::Symbol: Data set type\n\nid1::String: ID line 1\n\nid2::String: ID line 2\n\nid3::String: ID line 3\n\nid4::String: ID line 4\n\nid5::String: ID line 5\n\nmodel_type::Int: Model type\n\nanalysis_type::Int: Analysis type\n\ndata_charac::Int: Data characterization\n\nspec_dtype::Int: Specific data type\n\ndtype::Int: Data type\n\nndv_per_node::Int: Number of data values per node\n\nr7::NamedTuple: Analysis type specific\n\nr8::NamedTuple: Analysis type specific\n\nnode_number::Vector{Int}: Node numbers\n\ndata::Matrix{Union{Float64, ComplexF64}}: Data values",
    "crumbs": [
      "Datasets",
      "Dataset 55 - Data at nodes"
    ]
  },
  {
    "objectID": "datasets/dataset58.html",
    "href": "datasets/dataset58.html",
    "title": "Dataset 58 - Function at nodal DOF",
    "section": "",
    "text": "Universal Dataset Number: 58\nName:   Function at Nodal DOF\n     Record 1:     Format(80A1)\n                   Field 1    - ID Line 1\n\n                                             NOTE\n\n                       ID Line 1 is generally  used  for  the function\n                       description.\n\n\n     Record 2:     Format(80A1)\n                   Field 1    - ID Line 2\n\n     Record 3:     Format(80A1)\n                   Field 1    - ID Line 3\n\n                                             NOTE\n\n                       ID Line 3 is generally used to identify when the\n                       function  was  created.  The date is in the form\n                       DD-MMM-YY, and the time is in the form HH:MM:SS,\n                       with a general Format(9A1,1X,8A1).\n\n     Record 4:     Format(80A1)\n                   Field 1    - ID Line 4\n\n     Record 5:     Format(80A1)\n                   Field 1    - ID Line 5\n\n     Record 6:     Format(2(I5,I10),2(1X,10A1,I10,I4))\n                              DOF Identification\n                   Field 1    - Function Type\n                                0 - General or Unknown\n                                1 - Time Response\n                                2 - Auto Spectrum\n                                3 - Cross Spectrum\n                                4 - Frequency Response Function\n                                5 - Transmissibility\n                                6 - Coherence\n                                7 - Auto Correlation\n                                8 - Cross Correlation\n                                9 - Power Spectral Density (PSD)\n                                10 - Energy Spectral Density (ESD)\n                                11 - Probability Density Function\n                                12 - Spectrum\n                                13 - Cumulative Frequency Distribution\n                                14 - Peaks Valley\n                                15 - Stress/Cycles\n                                16 - Strain/Cycles\n                                17 - Orbit\n                                18 - Mode Indicator Function\n                                19 - Force Pattern\n                                20 - Partial Power\n                                21 - Partial Coherence\n                                22 - Eigenvalue\n                                23 - Eigenvector\n                                24 - Shock Response Spectrum\n                                25 - Finite Impulse Response Filter\n                                26 - Multiple Coherence\n                                27 - Order Function\n                   Field 2    - Function Identification Number\n                   Field 3    - Version Number, or sequence number\n                   Field 4    - Load Case Identification Number\n                                0 - Single Point Excitation\n                   Field 5    - Response Entity Name (\"NONE\" if unused)\n                   Field 6    - Response Node\n                   Field 7    - Response Direction\n                                 0 - Scalar\n                                 1 - +X Translation       4 - +X Rotation\n                                -1 - -X Translation      -4 - -X Rotation\n                                 2 - +Y Translation       5 - +Y Rotation\n                                -2 - -Y Translation      -5 - -Y Rotation\n                                 3 - +Z Translation       6 - +Z Rotation\n                                -3 - -Z Translation      -6 - -Z Rotation\n                   Field 8    - Reference Entity Name (\"NONE\" if unused)\n                   Field 9    - Reference Node\n                   Field 10   - Reference Direction  (same as field 7)\n\n                                             NOTE\n\n                       Fields 8, 9, and 10 are only relevant if field 4\n                       is zero.\n\n     Record 7:     Format(3I10,3E13.5)\n                              Data Form\n                   Field 1    - Ordinate Data Type\n                                2 - real, single precision\n                                4 - real, double precision\n                                5 - complex, single precision\n                                6 - complex, double precision\n                   Field 2    - Number of data pairs for uneven abscissa\n                                spacing, or number of data values for even\n                                abscissa spacing\n                   Field 3    - Abscissa Spacing\n                                0 - uneven\n                                1 - even (no abscissa values stored)\n                   Field 4    - Abscissa minimum (0.0 if spacing uneven)\n                   Field 5    - Abscissa increment (0.0 if spacing uneven)\n                   Field 6    - Z-axis value (0.0 if unused)\n\n     Record 8:     Format(I10,3I5,2(1X,20A1))\n                              Abscissa Data Characteristics\n                   Field 1    - Specific Data Type\n                                0 - unknown\n                                1 - general\n                                2 - stress\n                                3 - strain\n                                5 - temperature\n                                6 - heat flux\n                                8 - displacement\n                                9 - reaction force\n                                11 - velocity\n                                12 - acceleration\n                                13 - excitation force\n                                15 - pressure\n                                16 - mass\n                                17 - time\n                                18 - frequency\n                                19 - rpm\n                                20 - order\n                   Field 2    - Length units exponent\n                   Field 3    - Force units exponent\n                   Field 4    - Temperature units exponent\n\n                    NOTE\n\n                       Fields 2, 3 and  4  are  relevant  only  if the\n                       Specific Data Type is General, or in the case of\n                       ordinates, the response/reference direction is a\n                       scalar, or the functions are being used for\n                       nonlinear connectors in System Dynamics Analysis.\n                       See Addendum 'A' for the units exponent table.\n\n                   Field 5    - Axis label (\"NONE\" if not used)\n                   Field 6    - Axis units label (\"NONE\" if not used)\n\n                    NOTE\n\n                       If fields  5  and  6  are  supplied,  they take\n                       precendence  over  program  generated labels and\n                       units.\n\n     Record 9:     Format(I10,3I5,2(1X,20A1))\n                   Ordinate (or ordinate numerator) Data Characteristics\n\n     Record 10:    Format(I10,3I5,2(1X,20A1))\n                   Ordinate Denominator Data Characteristics\n\n     Record 11:    Format(I10,3I5,2(1X,20A1))\n                   Z-axis Data Characteristics\n\n                    NOTE\n\n                       Records 9, 10, and 11 are  always  included and\n                       have fields the same as record 8.  If records 10\n                       and 11 are not used, set field 1 to zero.\n\n     Record 12:\n                               Data Values\n\n                     Ordinate            Abscissa\n         Case     Type     Precision     Spacing       Format\n       -------------------------------------------------------------\n           1      real      single        even         6E13.5\n           2      real      single       uneven        6E13.5\n           3     complex    single        even         6E13.5\n           4     complex    single       uneven        6E13.5\n           5      real      double        even         4E20.12\n           6      real      double       uneven     2(E13.5,E20.12)\n           7     complex    double        even         4E20.12\n           8     complex    double       uneven      E13.5,2E20.12\n       --------------------------------------------------------------\n\n        NOTE\n\n       See  Addendum  'B'  for  typical  FORTRAN   READ/WRITE\n       statements for each case.\n\n\n     General Notes:\n\n          1.  ID lines may not be blank.  If no  information  is required,\n              the word \"NONE\" must appear in columns 1 through 4.\n\n          2.  ID line 1 appears on plots in Finite Element Modeling and is\n              used as the function description in System Dynamics Analysis.\n\n          3.  Dataloaders use the following ID line conventions\n                 ID Line 1 - Model Identification\n                 ID Line 2 - Run Identification\n                 ID Line 3 - Run Date and Time\n                 ID Line 4 - Load Case Name\n\n          4.  Coordinates codes from MODAL-PLUS and MODALX are decoded into\n              node and direction.\n\n          5.  Entity names used in System Dynamics Analysis prior to I-DEAS\n              Level 5 have a 4 character maximum. Beginning with Level 5,\n              entity names will be ignored if this dataset is preceded by\n              dataset 259. If no dataset 259 precedes this dataset, then the\n              entity name will be assumed to exist in model bin number 1.\n\n          6.  Record 10 is ignored by System Dynamics Analysis unless load\n              case = 0. Record 11 is always ignored by System Dynamics\n              Analysis.\n\n          7.  In record 6, if the response or reference names are \"NONE\"\n              and are not overridden by a dataset 259, but the correspond-\n              ing node is non-zero, System Dynamics Analysis adds the node\n              and direction to the function description if space is sufficie\n\n          8.  ID line 1 appears on XY plots in Test Data Analysis along\n              with ID line 5 if it is defined.  If defined, the axis units\n              labels also appear on the XY plot instead of the normal\n              labeling based on the data type of the function.\n\n          9.  For functions used with nonlinear connectors in System\n              Dynamics Analysis, the following requirements must be\n              adhered to:\n\n              a) Record 6: For a displacement-dependent function, the\n                 function type must be 0; for a frequency-dependent\n                 function, it must be 4. In either case, the load case\n                 identification number must be 0.\n\n              b) Record 8: For a displacement-dependent function, the\n                 specific data type must be 8 and the length units\n                 exponent must be 0 or 1; for a frequency-dependent\n                 function, the specific data type must be 18 and the\n                 length units exponent must be 0. In either case, the\n                 other units exponents must be 0.\n\n              c) Record 9: The specific data type must be 13. The\n                 temperature units exponent must be 0. For an ordinate\n                 numerator of force, the length and force units\n                 exponents must be 0 and 1, respectively. For an\n                 ordinate numerator of moment, the length and force\n                 units exponents must be 1 and 1, respectively.\n\n              d) Record 10: The specific data type must be 8 for\n                 stiffness and hysteretic damping; it must be 11\n                 for viscous damping. For an ordinate denominator of\n                 translational displacement, the length units exponent\n                 must be 1; for a rotational displacement, it must\n                 be 0. The other units exponents must be 0.\n\n              e) Dataset 217 must precede each function in order to\n                 define the function's usage (i.e. stiffness, viscous\n                 damping, hysteretic damping).\n\n    Addendum A\n\n     In order to correctly perform units  conversion,  length,  force, and\n     temperature  exponents  must  be  supplied for a specific data type of\n     General; that is, Record 8 Field 1 = 1.  For example, if the function\n     has  the  physical dimensionality of Energy (Force * Length), then the\n     required exponents would be as follows:\n\n             Length = 1\n             Force = 1          Energy = L * F\n             Temperature = 0\n\n     Units exponents for the remaining specific data types  should not  be\n     supplied.  The following exponents will automatically be used.\n\n                          Table - Unit Exponents\n          -------------------------------------------------------\n           Specific                   Direction\n                    ---------------------------------------------\n             Data       Translational            Rotational\n                    ---------------------------------------------\n             Type    Length  Force  Temp    Length  Force  Temp\n          -------------------------------------------------------\n              0        0       0      0       0       0      0\n              1             (requires input to fields 2,3,4)\n              2       -2       1      0      -1       1      0\n              3        0       0      0       0       0      0\n              5        0       0      1       0       0      1\n              6        1       1      0       1       1      0\n              8        1       0      0       0       0      0\n              9        0       1      0       1       1      0\n             11        1       0      0       0       0      0\n             12        1       0      0       0       0      0\n             13        0       1      0       1       1      0\n             15       -2       1      0      -1       1      0\n             16       -1       1      0       1       1      0\n             17        0       0      0       0       0      0\n             18        0       0      0       0       0      0\n             19        0       0      0       0       0      0\n          --------------------------------------------------------\n\n            NOTE\n\n             Units exponents for scalar points are defined within\n             System Analysis prior to reading this dataset.\n\n    Addendum B\n\n     There are 8 distinct  combinations  of  parameters  which  affect the\n     details   of  READ/WRITE  operations.   The  parameters  involved are\n     Ordinate Data Type, Ordinate Data  Precision,  and  Abscissa Spacing.\n     Each  combination  is documented in the examples below.  In all cases,\n     the number of data values (for even abscissa spacing)  or  data pairs\n     (for  uneven  abscissa  spacing)  is NVAL.  The abcissa is always real\n     single precision.  Complex double precision is  handled  by  two real\n     double  precision  variables  (real  part  followed by imaginary part)\n     because most systems do not directly support complex double precision.\n\n     CASE 1\n\n     REAL\n     SINGLE PRECISION\n     EVEN SPACING\n\n       Order of data in file           Y1   Y2   Y3   Y4   Y5   Y6\n                                       Y7   Y8   Y9   Y10  Y11  Y12\n                                                  .\n                                                  .\n                                                  .\n       Input\n\n                 REAL Y(6)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(Y(I),I=1,6)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+6\n                   .\n                   .    code to process these six values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n       Output\n\n                 REAL Y(6)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these six values\n                   .\n                 WRITE(LUN,1000,ERR=  )(Y(I),I=1,6)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+6\n\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n     CASE 2\n\n     REAL\n     SINGLE PRECISION\n     UNEVEN SPACING\n\n       Order of data in file          X1   Y1   X2   Y2   X3   Y3\n                                      X4   Y4   X5   Y5   X6   Y6\n                                       .\n                                       .\n                                       .\n\n       Input\n\n                 REAL X(3),Y(3)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(X(I),Y(I),I=1,3)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+3\n                   .\n                   .    code to process these three values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n       Output\n\n                 REAL X(3),Y(3)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these three values\n                   .\n                 WRITE(LUN,1000,ERR=  )(X(I),Y(I),I=1,3)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+3\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n     CASE 3\n\n     COMPLEX\n     SINGLE PRECISION\n     EVEN SPACING\n\n       Order of data in file          RY1  IY1  RY2  IY2  RY3  IY3\n                                      RY4  IY4  RY5  IY5  RY6  IY6\n                                       .\n                                       .\n                                       .\n\n       Input\n\n                 COMPLEX Y(3)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(Y(I),I=1,3)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+3\n                   .\n                   .    code to process these six values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n\n       Output\n\n                 COMPLEX Y(3)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these three values\n                   .\n                 WRITE(LUN,1000,ERR=  )(Y(I),I=1,3)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+3\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n     CASE 4\n\n     COMPLEX\n     SINGLE PRECISION\n     UNEVEN SPACING\n\n       Order of data in file          X1   RY1  IY1  X2  RY2  IY2\n                                      X3   RY3  IY3  X4  RY4  IY4\n\n                                       .\n                                       .\n                                       .\n\n       Input\n\n                 REAL X(2)\n                 COMPLEX Y(2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(X(I),Y(I),I=1,2)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+2\n                   .\n                   .    code to process these two values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n      Output\n\n                 REAL X(2)\n                 COMPLEX Y(2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these two values\n                   .\n                 WRITE(LUN,1000,ERR=  )(X(I),Y(I),I=1,2)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+2\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n     CASE 5\n\n     REAL\n     DOUBLE PRECISION\n     EVEN SPACING\n\n       Order of data in file          Y1     Y2     Y3     Y4\n                                      Y5     Y6     Y7     Y8\n                                       .\n                                       .\n                                       .\n       Input\n\n                 DOUBLE PRECISION Y(4)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(Y(I),I=1,4)\n            1000 FORMAT(4E20.12)\n                 NPRO=NPRO+4\n                   .\n                   .    code to process these four values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n       Output\n\n                 DOUBLE PRECISION Y(4)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these four values\n                   .\n                 WRITE(LUN,1000,ERR=  )(Y(I),I=1,4)\n            1000 FORMAT(4E20.12)\n                 NPRO=NPRO+4\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n     CASE 6\n\n     REAL\n     DOUBLE PRECISION\n     UNEVEN SPACING\n\n       Order of data in file          X1   Y1     X2   Y2\n                                      X3   Y3     X4   Y4\n                                       .\n                                       .\n                                       .\n       Input\n\n                 REAL X(2)\n                 DOUBLE PRECISION Y(2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(X(I),Y(I),I=1,2)\n            1000 FORMAT(2(E13.5,E20.12))\n                 NPRO=NPRO+2\n                   .\n                   .    code to process these two values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n       Output\n\n                 REAL X(2)\n                 DOUBLE PRECISION Y(2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these two values\n                   .\n                 WRITE(LUN,1000,ERR=  )(X(I),Y(I),I=1,2)\n            1000 FORMAT(2(E13.5,E20.12))\n                 NPRO=NPRO+2\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n     CASE 7\n\n     COMPLEX\n     DOUBLE PRECISION\n     EVEN SPACING\n\n       Order of data in file          RY1    IY1    RY2    IY2\n                                      RY3    IY3    RY4    IY4\n                                       .\n                                       .\n                                       .\n\n       Input\n\n                 DOUBLE PRECISION Y(2,2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )((Y(I,J),I=1,2),J=1,2)\n            1000 FORMAT(4E20.12)\n                 NPRO=NPRO+2\n                   .\n                   .    code to process these two values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n       Output\n\n                 DOUBLE PRECISION Y(2,2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these two values\n                   .\n                 WRITE(LUN,1000,ERR=  )((Y(I,J),I=1,2),J=1,2)\n            1000 FORMAT(4E20.12)\n                 NPRO=NPRO+2\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n     CASE 8\n\n     COMPLEX\n     DOUBLE PRECISION\n     UNEVEN SPACING\n\n       Order of data in file          X1   RY1    IY1\n                                      X2   RY2    IY2\n                                       .\n                                       .\n                                       .\n       Input\n\n                 REAL X\n                 DOUBLE PRECISION Y(2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(X,Y(I),I=1,2)\n            1000 FORMAT(E13.5,2E20.12)\n                 NPRO=NPRO+1\n                   .\n                   .    code to process this value\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n       Output\n\n                 REAL X\n                 DOUBLE PRECISION Y(2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up this value\n                   .\n                 WRITE(LUN,1000,ERR=  )(X,Y(I),I=1,2)\n            1000 FORMAT(E13.5,2E20.12)\n                 NPRO=NPRO+1\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .",
    "crumbs": [
      "Datasets",
      "Dataset 58 - Function at nodal DOF"
    ]
  },
  {
    "objectID": "datasets/dataset58.html#dataset-description",
    "href": "datasets/dataset58.html#dataset-description",
    "title": "Dataset 58 - Function at nodal DOF",
    "section": "",
    "text": "Universal Dataset Number: 58\nName:   Function at Nodal DOF\n     Record 1:     Format(80A1)\n                   Field 1    - ID Line 1\n\n                                             NOTE\n\n                       ID Line 1 is generally  used  for  the function\n                       description.\n\n\n     Record 2:     Format(80A1)\n                   Field 1    - ID Line 2\n\n     Record 3:     Format(80A1)\n                   Field 1    - ID Line 3\n\n                                             NOTE\n\n                       ID Line 3 is generally used to identify when the\n                       function  was  created.  The date is in the form\n                       DD-MMM-YY, and the time is in the form HH:MM:SS,\n                       with a general Format(9A1,1X,8A1).\n\n     Record 4:     Format(80A1)\n                   Field 1    - ID Line 4\n\n     Record 5:     Format(80A1)\n                   Field 1    - ID Line 5\n\n     Record 6:     Format(2(I5,I10),2(1X,10A1,I10,I4))\n                              DOF Identification\n                   Field 1    - Function Type\n                                0 - General or Unknown\n                                1 - Time Response\n                                2 - Auto Spectrum\n                                3 - Cross Spectrum\n                                4 - Frequency Response Function\n                                5 - Transmissibility\n                                6 - Coherence\n                                7 - Auto Correlation\n                                8 - Cross Correlation\n                                9 - Power Spectral Density (PSD)\n                                10 - Energy Spectral Density (ESD)\n                                11 - Probability Density Function\n                                12 - Spectrum\n                                13 - Cumulative Frequency Distribution\n                                14 - Peaks Valley\n                                15 - Stress/Cycles\n                                16 - Strain/Cycles\n                                17 - Orbit\n                                18 - Mode Indicator Function\n                                19 - Force Pattern\n                                20 - Partial Power\n                                21 - Partial Coherence\n                                22 - Eigenvalue\n                                23 - Eigenvector\n                                24 - Shock Response Spectrum\n                                25 - Finite Impulse Response Filter\n                                26 - Multiple Coherence\n                                27 - Order Function\n                   Field 2    - Function Identification Number\n                   Field 3    - Version Number, or sequence number\n                   Field 4    - Load Case Identification Number\n                                0 - Single Point Excitation\n                   Field 5    - Response Entity Name (\"NONE\" if unused)\n                   Field 6    - Response Node\n                   Field 7    - Response Direction\n                                 0 - Scalar\n                                 1 - +X Translation       4 - +X Rotation\n                                -1 - -X Translation      -4 - -X Rotation\n                                 2 - +Y Translation       5 - +Y Rotation\n                                -2 - -Y Translation      -5 - -Y Rotation\n                                 3 - +Z Translation       6 - +Z Rotation\n                                -3 - -Z Translation      -6 - -Z Rotation\n                   Field 8    - Reference Entity Name (\"NONE\" if unused)\n                   Field 9    - Reference Node\n                   Field 10   - Reference Direction  (same as field 7)\n\n                                             NOTE\n\n                       Fields 8, 9, and 10 are only relevant if field 4\n                       is zero.\n\n     Record 7:     Format(3I10,3E13.5)\n                              Data Form\n                   Field 1    - Ordinate Data Type\n                                2 - real, single precision\n                                4 - real, double precision\n                                5 - complex, single precision\n                                6 - complex, double precision\n                   Field 2    - Number of data pairs for uneven abscissa\n                                spacing, or number of data values for even\n                                abscissa spacing\n                   Field 3    - Abscissa Spacing\n                                0 - uneven\n                                1 - even (no abscissa values stored)\n                   Field 4    - Abscissa minimum (0.0 if spacing uneven)\n                   Field 5    - Abscissa increment (0.0 if spacing uneven)\n                   Field 6    - Z-axis value (0.0 if unused)\n\n     Record 8:     Format(I10,3I5,2(1X,20A1))\n                              Abscissa Data Characteristics\n                   Field 1    - Specific Data Type\n                                0 - unknown\n                                1 - general\n                                2 - stress\n                                3 - strain\n                                5 - temperature\n                                6 - heat flux\n                                8 - displacement\n                                9 - reaction force\n                                11 - velocity\n                                12 - acceleration\n                                13 - excitation force\n                                15 - pressure\n                                16 - mass\n                                17 - time\n                                18 - frequency\n                                19 - rpm\n                                20 - order\n                   Field 2    - Length units exponent\n                   Field 3    - Force units exponent\n                   Field 4    - Temperature units exponent\n\n                    NOTE\n\n                       Fields 2, 3 and  4  are  relevant  only  if the\n                       Specific Data Type is General, or in the case of\n                       ordinates, the response/reference direction is a\n                       scalar, or the functions are being used for\n                       nonlinear connectors in System Dynamics Analysis.\n                       See Addendum 'A' for the units exponent table.\n\n                   Field 5    - Axis label (\"NONE\" if not used)\n                   Field 6    - Axis units label (\"NONE\" if not used)\n\n                    NOTE\n\n                       If fields  5  and  6  are  supplied,  they take\n                       precendence  over  program  generated labels and\n                       units.\n\n     Record 9:     Format(I10,3I5,2(1X,20A1))\n                   Ordinate (or ordinate numerator) Data Characteristics\n\n     Record 10:    Format(I10,3I5,2(1X,20A1))\n                   Ordinate Denominator Data Characteristics\n\n     Record 11:    Format(I10,3I5,2(1X,20A1))\n                   Z-axis Data Characteristics\n\n                    NOTE\n\n                       Records 9, 10, and 11 are  always  included and\n                       have fields the same as record 8.  If records 10\n                       and 11 are not used, set field 1 to zero.\n\n     Record 12:\n                               Data Values\n\n                     Ordinate            Abscissa\n         Case     Type     Precision     Spacing       Format\n       -------------------------------------------------------------\n           1      real      single        even         6E13.5\n           2      real      single       uneven        6E13.5\n           3     complex    single        even         6E13.5\n           4     complex    single       uneven        6E13.5\n           5      real      double        even         4E20.12\n           6      real      double       uneven     2(E13.5,E20.12)\n           7     complex    double        even         4E20.12\n           8     complex    double       uneven      E13.5,2E20.12\n       --------------------------------------------------------------\n\n        NOTE\n\n       See  Addendum  'B'  for  typical  FORTRAN   READ/WRITE\n       statements for each case.\n\n\n     General Notes:\n\n          1.  ID lines may not be blank.  If no  information  is required,\n              the word \"NONE\" must appear in columns 1 through 4.\n\n          2.  ID line 1 appears on plots in Finite Element Modeling and is\n              used as the function description in System Dynamics Analysis.\n\n          3.  Dataloaders use the following ID line conventions\n                 ID Line 1 - Model Identification\n                 ID Line 2 - Run Identification\n                 ID Line 3 - Run Date and Time\n                 ID Line 4 - Load Case Name\n\n          4.  Coordinates codes from MODAL-PLUS and MODALX are decoded into\n              node and direction.\n\n          5.  Entity names used in System Dynamics Analysis prior to I-DEAS\n              Level 5 have a 4 character maximum. Beginning with Level 5,\n              entity names will be ignored if this dataset is preceded by\n              dataset 259. If no dataset 259 precedes this dataset, then the\n              entity name will be assumed to exist in model bin number 1.\n\n          6.  Record 10 is ignored by System Dynamics Analysis unless load\n              case = 0. Record 11 is always ignored by System Dynamics\n              Analysis.\n\n          7.  In record 6, if the response or reference names are \"NONE\"\n              and are not overridden by a dataset 259, but the correspond-\n              ing node is non-zero, System Dynamics Analysis adds the node\n              and direction to the function description if space is sufficie\n\n          8.  ID line 1 appears on XY plots in Test Data Analysis along\n              with ID line 5 if it is defined.  If defined, the axis units\n              labels also appear on the XY plot instead of the normal\n              labeling based on the data type of the function.\n\n          9.  For functions used with nonlinear connectors in System\n              Dynamics Analysis, the following requirements must be\n              adhered to:\n\n              a) Record 6: For a displacement-dependent function, the\n                 function type must be 0; for a frequency-dependent\n                 function, it must be 4. In either case, the load case\n                 identification number must be 0.\n\n              b) Record 8: For a displacement-dependent function, the\n                 specific data type must be 8 and the length units\n                 exponent must be 0 or 1; for a frequency-dependent\n                 function, the specific data type must be 18 and the\n                 length units exponent must be 0. In either case, the\n                 other units exponents must be 0.\n\n              c) Record 9: The specific data type must be 13. The\n                 temperature units exponent must be 0. For an ordinate\n                 numerator of force, the length and force units\n                 exponents must be 0 and 1, respectively. For an\n                 ordinate numerator of moment, the length and force\n                 units exponents must be 1 and 1, respectively.\n\n              d) Record 10: The specific data type must be 8 for\n                 stiffness and hysteretic damping; it must be 11\n                 for viscous damping. For an ordinate denominator of\n                 translational displacement, the length units exponent\n                 must be 1; for a rotational displacement, it must\n                 be 0. The other units exponents must be 0.\n\n              e) Dataset 217 must precede each function in order to\n                 define the function's usage (i.e. stiffness, viscous\n                 damping, hysteretic damping).\n\n    Addendum A\n\n     In order to correctly perform units  conversion,  length,  force, and\n     temperature  exponents  must  be  supplied for a specific data type of\n     General; that is, Record 8 Field 1 = 1.  For example, if the function\n     has  the  physical dimensionality of Energy (Force * Length), then the\n     required exponents would be as follows:\n\n             Length = 1\n             Force = 1          Energy = L * F\n             Temperature = 0\n\n     Units exponents for the remaining specific data types  should not  be\n     supplied.  The following exponents will automatically be used.\n\n                          Table - Unit Exponents\n          -------------------------------------------------------\n           Specific                   Direction\n                    ---------------------------------------------\n             Data       Translational            Rotational\n                    ---------------------------------------------\n             Type    Length  Force  Temp    Length  Force  Temp\n          -------------------------------------------------------\n              0        0       0      0       0       0      0\n              1             (requires input to fields 2,3,4)\n              2       -2       1      0      -1       1      0\n              3        0       0      0       0       0      0\n              5        0       0      1       0       0      1\n              6        1       1      0       1       1      0\n              8        1       0      0       0       0      0\n              9        0       1      0       1       1      0\n             11        1       0      0       0       0      0\n             12        1       0      0       0       0      0\n             13        0       1      0       1       1      0\n             15       -2       1      0      -1       1      0\n             16       -1       1      0       1       1      0\n             17        0       0      0       0       0      0\n             18        0       0      0       0       0      0\n             19        0       0      0       0       0      0\n          --------------------------------------------------------\n\n            NOTE\n\n             Units exponents for scalar points are defined within\n             System Analysis prior to reading this dataset.\n\n    Addendum B\n\n     There are 8 distinct  combinations  of  parameters  which  affect the\n     details   of  READ/WRITE  operations.   The  parameters  involved are\n     Ordinate Data Type, Ordinate Data  Precision,  and  Abscissa Spacing.\n     Each  combination  is documented in the examples below.  In all cases,\n     the number of data values (for even abscissa spacing)  or  data pairs\n     (for  uneven  abscissa  spacing)  is NVAL.  The abcissa is always real\n     single precision.  Complex double precision is  handled  by  two real\n     double  precision  variables  (real  part  followed by imaginary part)\n     because most systems do not directly support complex double precision.\n\n     CASE 1\n\n     REAL\n     SINGLE PRECISION\n     EVEN SPACING\n\n       Order of data in file           Y1   Y2   Y3   Y4   Y5   Y6\n                                       Y7   Y8   Y9   Y10  Y11  Y12\n                                                  .\n                                                  .\n                                                  .\n       Input\n\n                 REAL Y(6)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(Y(I),I=1,6)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+6\n                   .\n                   .    code to process these six values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n       Output\n\n                 REAL Y(6)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these six values\n                   .\n                 WRITE(LUN,1000,ERR=  )(Y(I),I=1,6)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+6\n\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n     CASE 2\n\n     REAL\n     SINGLE PRECISION\n     UNEVEN SPACING\n\n       Order of data in file          X1   Y1   X2   Y2   X3   Y3\n                                      X4   Y4   X5   Y5   X6   Y6\n                                       .\n                                       .\n                                       .\n\n       Input\n\n                 REAL X(3),Y(3)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(X(I),Y(I),I=1,3)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+3\n                   .\n                   .    code to process these three values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n       Output\n\n                 REAL X(3),Y(3)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these three values\n                   .\n                 WRITE(LUN,1000,ERR=  )(X(I),Y(I),I=1,3)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+3\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n     CASE 3\n\n     COMPLEX\n     SINGLE PRECISION\n     EVEN SPACING\n\n       Order of data in file          RY1  IY1  RY2  IY2  RY3  IY3\n                                      RY4  IY4  RY5  IY5  RY6  IY6\n                                       .\n                                       .\n                                       .\n\n       Input\n\n                 COMPLEX Y(3)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(Y(I),I=1,3)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+3\n                   .\n                   .    code to process these six values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n\n       Output\n\n                 COMPLEX Y(3)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these three values\n                   .\n                 WRITE(LUN,1000,ERR=  )(Y(I),I=1,3)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+3\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n     CASE 4\n\n     COMPLEX\n     SINGLE PRECISION\n     UNEVEN SPACING\n\n       Order of data in file          X1   RY1  IY1  X2  RY2  IY2\n                                      X3   RY3  IY3  X4  RY4  IY4\n\n                                       .\n                                       .\n                                       .\n\n       Input\n\n                 REAL X(2)\n                 COMPLEX Y(2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(X(I),Y(I),I=1,2)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+2\n                   .\n                   .    code to process these two values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n      Output\n\n                 REAL X(2)\n                 COMPLEX Y(2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these two values\n                   .\n                 WRITE(LUN,1000,ERR=  )(X(I),Y(I),I=1,2)\n            1000 FORMAT(6E13.5)\n                 NPRO=NPRO+2\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n     CASE 5\n\n     REAL\n     DOUBLE PRECISION\n     EVEN SPACING\n\n       Order of data in file          Y1     Y2     Y3     Y4\n                                      Y5     Y6     Y7     Y8\n                                       .\n                                       .\n                                       .\n       Input\n\n                 DOUBLE PRECISION Y(4)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(Y(I),I=1,4)\n            1000 FORMAT(4E20.12)\n                 NPRO=NPRO+4\n                   .\n                   .    code to process these four values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n       Output\n\n                 DOUBLE PRECISION Y(4)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these four values\n                   .\n                 WRITE(LUN,1000,ERR=  )(Y(I),I=1,4)\n            1000 FORMAT(4E20.12)\n                 NPRO=NPRO+4\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n     CASE 6\n\n     REAL\n     DOUBLE PRECISION\n     UNEVEN SPACING\n\n       Order of data in file          X1   Y1     X2   Y2\n                                      X3   Y3     X4   Y4\n                                       .\n                                       .\n                                       .\n       Input\n\n                 REAL X(2)\n                 DOUBLE PRECISION Y(2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(X(I),Y(I),I=1,2)\n            1000 FORMAT(2(E13.5,E20.12))\n                 NPRO=NPRO+2\n                   .\n                   .    code to process these two values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n       Output\n\n                 REAL X(2)\n                 DOUBLE PRECISION Y(2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these two values\n                   .\n                 WRITE(LUN,1000,ERR=  )(X(I),Y(I),I=1,2)\n            1000 FORMAT(2(E13.5,E20.12))\n                 NPRO=NPRO+2\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n     CASE 7\n\n     COMPLEX\n     DOUBLE PRECISION\n     EVEN SPACING\n\n       Order of data in file          RY1    IY1    RY2    IY2\n                                      RY3    IY3    RY4    IY4\n                                       .\n                                       .\n                                       .\n\n       Input\n\n                 DOUBLE PRECISION Y(2,2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )((Y(I,J),I=1,2),J=1,2)\n            1000 FORMAT(4E20.12)\n                 NPRO=NPRO+2\n                   .\n                   .    code to process these two values\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n       Output\n\n                 DOUBLE PRECISION Y(2,2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up these two values\n                   .\n                 WRITE(LUN,1000,ERR=  )((Y(I,J),I=1,2),J=1,2)\n            1000 FORMAT(4E20.12)\n                 NPRO=NPRO+2\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n     CASE 8\n\n     COMPLEX\n     DOUBLE PRECISION\n     UNEVEN SPACING\n\n       Order of data in file          X1   RY1    IY1\n                                      X2   RY2    IY2\n                                       .\n                                       .\n                                       .\n       Input\n\n                 REAL X\n                 DOUBLE PRECISION Y(2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 READ(LUN,1000,ERR=  ,END=  )(X,Y(I),I=1,2)\n            1000 FORMAT(E13.5,2E20.12)\n                 NPRO=NPRO+1\n                   .\n                   .    code to process this value\n                   .\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .\n\n       Output\n\n                 REAL X\n                 DOUBLE PRECISION Y(2)\n                   .\n                   .\n                   .\n                 NPRO=0\n              10 CONTINUE\n                   .\n                   .    code to set up this value\n                   .\n                 WRITE(LUN,1000,ERR=  )(X,Y(I),I=1,2)\n            1000 FORMAT(E13.5,2E20.12)\n                 NPRO=NPRO+1\n                 IF(NPRO.LT.NVAL)GO TO 10\n                   .\n                   .   continued processing\n                   .",
    "crumbs": [
      "Datasets",
      "Dataset 58 - Function at nodal DOF"
    ]
  },
  {
    "objectID": "datasets/dataset58.html#api",
    "href": "datasets/dataset58.html#api",
    "title": "Dataset 58 - Function at nodal DOF",
    "section": "2 API",
    "text": "2 API\n\n\n\nDataset58\nA struct containing UFF Dataset 58 metadata.\nFields\n\ntype::Symbol: Data set type\n\nid1::String: ID line 1\n\nid2::String: ID line 2\n\nid3::String: ID line 3\n\nid4::String: ID line 4\n\nid5::String: ID line 5\n\nfunc_type::Int: Function type\n\nfunc_id::Int: Function ID\n\nver_num::Int: Version number\n\nload_case::Int: Load case\n\nresp_name::String: Response name\n\nresp_node::Int: Response node\n\nresp_dir::Int: Response direction\n\nref_name::String: Reference name\n\nref_node::Int: Reference node\n\nref_dir::Int: Reference direction\n\nord_dtype::Int: Ordinate data type\n\nnum_pts::Int: Number of points\n\nabs_spacing_type::Int: Abscissa spacing type\n\nabs_start::Float64: Abscissa start\n\nabs_increment::Float64: Abscissa increment\n\nzval::Float64: Z-axis value\n\nabs_spec_dtype::Int: Abscissa specification data type\n\nabs_len_unit_exp::Int: Abscissa length unit exponent\n\nabs_force_unit_exp::Int: Abscissa force unit exponent\n\nabs_temp_unit_exp::Int: Abscissa temperature unit exponent\n\nabs_axis_label::String: Abscissa axis label\n\nabs_axis_unit_label::String: Abscissa axis unit label\n\nord_spec_dtype::Int: Ordinate specification data type\n\nord_len_unit_exp::Int: Ordinate length unit exponent\n\nord_force_unit_exp::Int: Ordinate force unit exponent\n\nord_temp_unit_exp::Int: Ordinate temperature unit exponent\n\nord_axis_label::String: Ordinate axis label\n\nord_axis_unit_label::String: Ordinate axis unit label\n\nord_denom_spec_dtype::Int: Ordinate denominator specification data type\n\nord_denom_len_unit_exp::Int: Ordinate denominator length unit exponent\n\nord_denom_force_unit_exp::Int: Ordinate denominator force unit exponent\n\nord_denom_temp_unit_exp::Int: Ordinate denominator temperature unit exponent\n\nord_denom_axis_label::String: Ordinate denominator axis label\n\nord_denom_axis_unit_label::String: Ordinate denominator axis unit label\n\nz_spec_dtype::Int: Z-axis specification data type\n\nz_len_unit_exp::Int: Z-axis length unit exponent\n\nz_force_unit_exp::Int: Z-axis force unit exponent\n\nz_temp_unit_exp::Int: Z-axis temperature unit exponent\n\nz_axis_label::String: Z-axis label\n\nz_axis_unit_label::String: Z-axis unit label\n\ndata::AbstractVector: Data values",
    "crumbs": [
      "Datasets",
      "Dataset 58 - Function at nodal DOF"
    ]
  },
  {
    "objectID": "datasets/dataset15.html",
    "href": "datasets/dataset15.html",
    "title": "Dataset 15 - Nodes",
    "section": "",
    "text": "Universal Dataset Number: 15\nName:   Nodes\n         Record 1: FORMAT(4I10,1P3E13.5)\n                   Field 1   -  node label\n                   Field 2   -  definition coordinate system number\n                   Field 3   -  displacement coordinate system number\n                   Field 4   -  color\n                   Field 5-7 -  3 - Dimensional coordinates of node\n                                in the definition system\n\n         NOTE:  Repeat record for each node",
    "crumbs": [
      "Datasets",
      "Dataset 15 - Nodes"
    ]
  },
  {
    "objectID": "datasets/dataset15.html#dataset-description",
    "href": "datasets/dataset15.html#dataset-description",
    "title": "Dataset 15 - Nodes",
    "section": "",
    "text": "Universal Dataset Number: 15\nName:   Nodes\n         Record 1: FORMAT(4I10,1P3E13.5)\n                   Field 1   -  node label\n                   Field 2   -  definition coordinate system number\n                   Field 3   -  displacement coordinate system number\n                   Field 4   -  color\n                   Field 5-7 -  3 - Dimensional coordinates of node\n                                in the definition system\n\n         NOTE:  Repeat record for each node",
    "crumbs": [
      "Datasets",
      "Dataset 15 - Nodes"
    ]
  },
  {
    "objectID": "datasets/dataset15.html#api",
    "href": "datasets/dataset15.html#api",
    "title": "Dataset 15 - Nodes",
    "section": "2 API",
    "text": "2 API\n\n\n\nDataset15\nA struct containing UFF Dataset 15 metadata.\nFields\n\ntype::Symbol: Data set type\n\nnode_ID::Vector{Int}: Node label\n\ndef_cs_num::Vector{Int}: Definition coordinate system number\n\ndisp_cs_num::Vector{Int}: Displacement coordinate system number\n\ncolor::Vector{Int}: Color\n\ncoords::Vector{Vector{Float64}}: 3D coordinates of node in the definition system",
    "crumbs": [
      "Datasets",
      "Dataset 15 - Nodes"
    ]
  },
  {
    "objectID": "usage/helper.html",
    "href": "usage/helper.html",
    "title": "Helper functions",
    "section": "",
    "text": "UFFFiles.jl provides several helper functions to facilitate interaction with UFF datasets.",
    "crumbs": [
      "Usage",
      "Helper functions"
    ]
  },
  {
    "objectID": "usage/helper.html#dataset-type",
    "href": "usage/helper.html#dataset-type",
    "title": "Helper functions",
    "section": "1 Dataset Type",
    "text": "1 Dataset Type\n\n\n\ndataset_type(data::UFFDataset)\nReturns the dataset type presents in a UFFDataset object.\nInput\n\ndata::UFFDataset: The UFFDataset object to extract types from.\n\n\nOutput\n\nSymbol: A vector containing the dataset types.\n\n\n\n\n\n\n\n\nusing UFFFiles\n\n# Only one dataset is read\ndata = readuff(\"path/to/your/file.uff\")[1]\ndtype = dataset_types(data)\n\n# Several datasets are read\ndata_all = readuff(\"path/to/your/file.uff\")\ndtypes = dataset_types.(data_all)",
    "crumbs": [
      "Usage",
      "Helper functions"
    ]
  },
  {
    "objectID": "usage/helper.html#supported-datasets",
    "href": "usage/helper.html#supported-datasets",
    "title": "Helper functions",
    "section": "2 Supported Datasets",
    "text": "2 Supported Datasets\n\n\n\nsupported_datasets()\nReturns a vector of supported UFF dataset types.\n\n\n\n\n\n\nusing UFFFiles\n\nvalid_datasets = supported_datasets()",
    "crumbs": [
      "Usage",
      "Helper functions"
    ]
  },
  {
    "objectID": "usage/helper.html#connectivity-matrix",
    "href": "usage/helper.html#connectivity-matrix",
    "title": "Helper functions",
    "section": "3 Connectivity Matrix",
    "text": "3 Connectivity Matrix\n\n\n\nconnectivity_matrix(dataset::Dataset2412)\nReturns the connectivity matrix for a Dataset2412 object, where each row corresponds to an element and each column corresponds to a node. Missing values are filled with -1.\nInput\n\ndataset::Dataset2412: The Dataset2412 object to extract connectivity from.\n\n\nOutput\n\nMatrix{Int}: A matrix representing the connectivity of elements to nodes.\n\n\n\n\n\n\n\n\nusing UFFFiles\n\n# readuff returns a vector of datasets\ndata2412 = readuff(\"path/to/your/file2412.uff\")[1]\nconnectivity = connectivity_matrix(data2412)",
    "crumbs": [
      "Usage",
      "Helper functions"
    ]
  },
  {
    "objectID": "usage/helper.html#dataset-55-to-matrix",
    "href": "usage/helper.html#dataset-55-to-matrix",
    "title": "Helper functions",
    "section": "4 Dataset 55 to matrix",
    "text": "4 Dataset 55 to matrix\n\n\n\ndataset55_to_mat(dataset::Vector{Dataset55})\nConverts a vector of Dataset55 objects into a matrix of data values and a vector of corresponding x-values based on the analysis type.\nInput\n\ndataset::Vector{Dataset55}: A vector of Dataset55 objects to be converted\n\n\nOutputs\n\nmat::VecOrMat{dtype}: A matrix where each column corresponds to a dataset's data values.\n\nx::Vector{xtype}: Vector of x-values corresponding to each dataset based on its analysis type.\n\n\nNote\n\ndtype and xtype depend on the dataset's dtype and analysis_type respectively.\n\nIt is assumed that all datasets in the input vector have the same number of data points and analysis type.\n\n\n\n\n\n\n\n\nusing UFFFiles\n\n# Let's assume you have read a UFF file containing dataset 55 only\ndata55 = readuff(\"path/to/your/file55.uff\")\n\n# Convert dataset 55 to a matrix\nmatrix55, x = dataset55_to_mat(data55)",
    "crumbs": [
      "Usage",
      "Helper functions"
    ]
  },
  {
    "objectID": "usage/helper.html#dataset-58-to-matrix",
    "href": "usage/helper.html#dataset-58-to-matrix",
    "title": "Helper functions",
    "section": "5 Dataset 58 to matrix",
    "text": "5 Dataset 58 to matrix\n\n\n\ndataset58_to_mat(dataset::Vector{Dataset58})\nConverts a vector of Dataset58 objects into a matrix of data values and a vector of corresponding x-values based on the dataset parameters.\nInput\n\ndataset::Vector{Dataset58}: A vector of Dataset58 objects to be converted\n\n\nOutputs\n\nmat::VecOrMat{dtype}: A matrix where each row corresponds to a dataset's data values.\n\nx::Vector{xtype}: A vector of x-values corresponding to each dataset based on its parameters.\n\n\nNote\n\ndtype and xtype depend on the dataset's ord_dtype.\n\nIt is assumed that all datasets in the input vector have the same number of data points and data type.\n\n\n\n\n\n\n\n\nusing UFFFiles\n\n# Let's assume you have read a UFF file containing dataset 58 only\ndata58 = readuff(\"path/to/your/file58.uff\")\n\n# Convert dataset 58 to a matrix\nmatrix58, x = dataset58_to_matrix(data58)",
    "crumbs": [
      "Usage",
      "Helper functions"
    ]
  },
  {
    "objectID": "overview/release_notes.html",
    "href": "overview/release_notes.html",
    "title": "Release Notes",
    "section": "",
    "text": "Breaking changes\n\nconversion_factors field in Dataset164 struct has been modified in favor of individual names for scaling factors. This change improves fields clarity. Thanks to @JakeZw for submitting the PR.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.3.0",
    "href": "overview/release_notes.html#v0.3.0",
    "title": "Release Notes",
    "section": "",
    "text": "Breaking changes\n\nconversion_factors field in Dataset164 struct has been modified in favor of individual names for scaling factors. This change improves fields clarity. Thanks to @JakeZw for submitting the PR.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.2.1",
    "href": "overview/release_notes.html#v0.2.1",
    "title": "Release Notes",
    "section": "v0.2.1",
    "text": "v0.2.1\nInternals changes only\n\nSkipping unsupported dataset blocks during UFF file parsing, with a warning message instead of throwing an error.\nRemove parse_dataset function in favor of getfield(UFFFiles, Symbol(\"parse_dataset\", dtype)) calls in read_uff function. Thanks to @JakeZw\nModify parse_dataset58 to handle lines without spacing between values.\nUse multiple dispatch to write dataset blocks in a more modular way.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.2.0",
    "href": "overview/release_notes.html#v0.2.0",
    "title": "Release Notes",
    "section": "v0.2.0",
    "text": "v0.2.0\n\nImplementation of writing functionality for all the datasets in the package.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.1.0",
    "href": "overview/release_notes.html#v0.1.0",
    "title": "Release Notes",
    "section": "v0.1.0",
    "text": "v0.1.0\n\nInitial release of the package",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  }
]